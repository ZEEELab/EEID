{"ast":null,"code":"/**\n * @fileOverview Defines an image nodes for webglGraphics class.\n * Shape of nodes is square.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nvar WebglAtlas = require('./webglAtlas.js');\nvar glUtils = require('./webgl.js');\nmodule.exports = webglImageNodeProgram;\n\n/**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as an image.\n * \n * @param {number} tilesPerTexture\n * \n */\nfunction webglImageNodeProgram(tilesPerTexture) {\n  // WebGL is gian state machine, we store some properties of the state here:\n  var ATTRIBUTES_PER_PRIMITIVE = 18;\n  var nodesFS = createNodeFragmentShader();\n  var nodesVS = createNodeVertexShader();\n  var tilesPerTexture = tilesPerTexture || 1024; // TODO: Get based on max texture size\n  var atlas;\n  var program;\n  var gl;\n  var buffer;\n  var utils;\n  var locations;\n  var nodesCount = 0;\n  var nodes = new Float32Array(64);\n  var width;\n  var height;\n  var transform;\n  var sizeDirty;\n  return {\n    load: load,\n    /**\n     * Updates position of current node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n    position: position,\n    createNode: createNode,\n    removeNode: removeNode,\n    replaceProperties: replaceProperties,\n    updateTransform: updateTransform,\n    updateSize: updateSize,\n    render: render\n  };\n  function refreshTexture(texture, idx) {\n    if (texture.nativeObject) {\n      gl.deleteTexture(texture.nativeObject);\n    }\n    var nativeObject = gl.createTexture();\n    gl.activeTexture(gl[\"TEXTURE\" + idx]);\n    gl.bindTexture(gl.TEXTURE_2D, nativeObject);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.canvas);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n    gl.generateMipmap(gl.TEXTURE_2D);\n    gl.uniform1i(locations[\"sampler\" + idx], idx);\n    texture.nativeObject = nativeObject;\n  }\n  function ensureAtlasTextureUpdated() {\n    if (atlas.isDirty) {\n      var textures = atlas.getTextures(),\n        i;\n      for (i = 0; i < textures.length; ++i) {\n        if (textures[i].isDirty || !textures[i].nativeObject) {\n          refreshTexture(textures[i], i);\n        }\n      }\n      atlas.clearDirty();\n    }\n  }\n  function load(glContext) {\n    gl = glContext;\n    utils = glUtils(glContext);\n    atlas = new WebglAtlas(tilesPerTexture);\n    program = utils.createProgram(nodesVS, nodesFS);\n    gl.useProgram(program);\n    locations = utils.getLocations(program, [\"a_vertexPos\", \"a_customAttributes\", \"u_screenSize\", \"u_transform\", \"u_sampler0\", \"u_sampler1\", \"u_sampler2\", \"u_sampler3\", \"u_tilesPerTexture\"]);\n    gl.uniform1f(locations.tilesPerTexture, tilesPerTexture);\n    gl.enableVertexAttribArray(locations.vertexPos);\n    gl.enableVertexAttribArray(locations.customAttributes);\n    buffer = gl.createBuffer();\n  }\n  function position(nodeUI, pos) {\n    var idx = nodeUI.id * ATTRIBUTES_PER_PRIMITIVE;\n    nodes[idx] = pos.x - nodeUI.size;\n    nodes[idx + 1] = -pos.y - nodeUI.size;\n    nodes[idx + 2] = nodeUI._offset * 4;\n    nodes[idx + 3] = pos.x + nodeUI.size;\n    nodes[idx + 4] = -pos.y - nodeUI.size;\n    nodes[idx + 5] = nodeUI._offset * 4 + 1;\n    nodes[idx + 6] = pos.x - nodeUI.size;\n    nodes[idx + 7] = -pos.y + nodeUI.size;\n    nodes[idx + 8] = nodeUI._offset * 4 + 2;\n    nodes[idx + 9] = pos.x - nodeUI.size;\n    nodes[idx + 10] = -pos.y + nodeUI.size;\n    nodes[idx + 11] = nodeUI._offset * 4 + 2;\n    nodes[idx + 12] = pos.x + nodeUI.size;\n    nodes[idx + 13] = -pos.y - nodeUI.size;\n    nodes[idx + 14] = nodeUI._offset * 4 + 1;\n    nodes[idx + 15] = pos.x + nodeUI.size;\n    nodes[idx + 16] = -pos.y + nodeUI.size;\n    nodes[idx + 17] = nodeUI._offset * 4 + 3;\n  }\n  function createNode(ui) {\n    nodes = utils.extendArray(nodes, nodesCount, ATTRIBUTES_PER_PRIMITIVE);\n    nodesCount += 1;\n    var coordinates = atlas.getCoordinates(ui.src);\n    if (coordinates) {\n      ui._offset = coordinates.offset;\n    } else {\n      ui._offset = 0;\n      // Image is not yet loaded into the atlas. Reload it:\n      atlas.load(ui.src, function (coordinates) {\n        ui._offset = coordinates.offset;\n      });\n    }\n  }\n  function removeNode(nodeUI) {\n    if (nodesCount > 0) {\n      nodesCount -= 1;\n    }\n    if (nodeUI.id < nodesCount && nodesCount > 0) {\n      if (nodeUI.src) {\n        atlas.remove(nodeUI.src);\n      }\n      utils.copyArrayPart(nodes, nodeUI.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n    }\n  }\n  function replaceProperties(replacedNode, newNode) {\n    newNode._offset = replacedNode._offset;\n  }\n  function updateTransform(newTransform) {\n    sizeDirty = true;\n    transform = newTransform;\n  }\n  function updateSize(w, h) {\n    width = w;\n    height = h;\n    sizeDirty = true;\n  }\n  function render() {\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, nodes, gl.DYNAMIC_DRAW);\n    if (sizeDirty) {\n      sizeDirty = false;\n      gl.uniformMatrix4fv(locations.transform, false, transform);\n      gl.uniform2f(locations.screenSize, width, height);\n    }\n    gl.vertexAttribPointer(locations.vertexPos, 2, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(locations.customAttributes, 1, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 2 * 4);\n    ensureAtlasTextureUpdated();\n    gl.drawArrays(gl.TRIANGLES, 0, nodesCount * 6);\n  }\n}\n\n// TODO: Use glslify for shaders\nfunction createNodeFragmentShader() {\n  return [\"precision mediump float;\", \"varying vec4 color;\", \"varying vec3 vTextureCoord;\", \"uniform sampler2D u_sampler0;\", \"uniform sampler2D u_sampler1;\", \"uniform sampler2D u_sampler2;\", \"uniform sampler2D u_sampler3;\", \"void main(void) {\", \"   if (vTextureCoord.z == 0.) {\", \"     gl_FragColor = texture2D(u_sampler0, vTextureCoord.xy);\", \"   } else if (vTextureCoord.z == 1.) {\", \"     gl_FragColor = texture2D(u_sampler1, vTextureCoord.xy);\", \"   } else if (vTextureCoord.z == 2.) {\", \"     gl_FragColor = texture2D(u_sampler2, vTextureCoord.xy);\", \"   } else if (vTextureCoord.z == 3.) {\", \"     gl_FragColor = texture2D(u_sampler3, vTextureCoord.xy);\", \"   } else { gl_FragColor = vec4(0, 1, 0, 1); }\", \"}\"].join(\"\\n\");\n}\nfunction createNodeVertexShader() {\n  return [\"attribute vec2 a_vertexPos;\", \"attribute float a_customAttributes;\", \"uniform vec2 u_screenSize;\", \"uniform mat4 u_transform;\", \"uniform float u_tilesPerTexture;\", \"varying vec3 vTextureCoord;\", \"void main(void) {\", \"   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0, 1);\", \"float corner = mod(a_customAttributes, 4.);\", \"float tileIndex = mod(floor(a_customAttributes / 4.), u_tilesPerTexture);\", \"float tilesPerRow = sqrt(u_tilesPerTexture);\", \"float tileSize = 1./tilesPerRow;\", \"float tileColumn = mod(tileIndex, tilesPerRow);\", \"float tileRow = floor(tileIndex/tilesPerRow);\", \"if(corner == 0.0) {\", \"  vTextureCoord.xy = vec2(0, 1);\", \"} else if(corner == 1.0) {\", \"  vTextureCoord.xy = vec2(1, 1);\", \"} else if(corner == 2.0) {\", \"  vTextureCoord.xy = vec2(0, 0);\", \"} else {\", \"  vTextureCoord.xy = vec2(1, 0);\", \"}\", \"vTextureCoord *= tileSize;\", \"vTextureCoord.x += tileColumn * tileSize;\", \"vTextureCoord.y += tileRow * tileSize;\", \"vTextureCoord.z = floor(floor(a_customAttributes / 4.)/u_tilesPerTexture);\", \"}\"].join(\"\\n\");\n}","map":{"version":3,"names":["WebglAtlas","require","glUtils","module","exports","webglImageNodeProgram","tilesPerTexture","ATTRIBUTES_PER_PRIMITIVE","nodesFS","createNodeFragmentShader","nodesVS","createNodeVertexShader","atlas","program","gl","buffer","utils","locations","nodesCount","nodes","Float32Array","width","height","transform","sizeDirty","load","position","createNode","removeNode","replaceProperties","updateTransform","updateSize","render","refreshTexture","texture","idx","nativeObject","deleteTexture","createTexture","activeTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","canvas","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_NEAREST","generateMipmap","uniform1i","ensureAtlasTextureUpdated","isDirty","textures","getTextures","i","length","clearDirty","glContext","createProgram","useProgram","getLocations","uniform1f","enableVertexAttribArray","vertexPos","customAttributes","createBuffer","nodeUI","pos","id","x","size","y","_offset","ui","extendArray","coordinates","getCoordinates","src","offset","remove","copyArrayPart","replacedNode","newNode","newTransform","w","h","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","uniformMatrix4fv","uniform2f","screenSize","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawArrays","TRIANGLES","join"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/vivagraphjs/src/WebGL/webglImageNodeProgram.js"],"sourcesContent":["/**\n * @fileOverview Defines an image nodes for webglGraphics class.\n * Shape of nodes is square.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nvar WebglAtlas = require('./webglAtlas.js');\nvar glUtils = require('./webgl.js');\n\nmodule.exports = webglImageNodeProgram;\n\n/**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as an image.\n * \n * @param {number} tilesPerTexture\n * \n */\nfunction webglImageNodeProgram(tilesPerTexture) {\n  // WebGL is gian state machine, we store some properties of the state here:\n  var ATTRIBUTES_PER_PRIMITIVE = 18;\n  var nodesFS = createNodeFragmentShader();\n  var nodesVS = createNodeVertexShader();\n  var tilesPerTexture = tilesPerTexture || 1024; // TODO: Get based on max texture size\n  var atlas;\n  var program;\n  var gl;\n  var buffer;\n  var utils;\n  var locations;\n  var nodesCount = 0;\n  var nodes = new Float32Array(64);\n  var width;\n  var height;\n  var transform;\n  var sizeDirty;\n\n\n  return {\n    load: load,\n\n    /**\n     * Updates position of current node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n    position: position,\n\n    createNode: createNode,\n\n    removeNode: removeNode,\n\n    replaceProperties: replaceProperties,\n\n    updateTransform: updateTransform,\n\n    updateSize: updateSize,\n\n    render: render\n  };\n\n  function refreshTexture(texture, idx) {\n    if (texture.nativeObject) {\n      gl.deleteTexture(texture.nativeObject);\n    }\n\n    var nativeObject = gl.createTexture();\n    gl.activeTexture(gl[\"TEXTURE\" + idx]);\n    gl.bindTexture(gl.TEXTURE_2D, nativeObject);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.canvas);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n\n    gl.generateMipmap(gl.TEXTURE_2D);\n    gl.uniform1i(locations[\"sampler\" + idx], idx);\n\n    texture.nativeObject = nativeObject;\n  }\n\n  function ensureAtlasTextureUpdated() {\n    if (atlas.isDirty) {\n      var textures = atlas.getTextures(),\n        i;\n      for (i = 0; i < textures.length; ++i) {\n        if (textures[i].isDirty || !textures[i].nativeObject) {\n          refreshTexture(textures[i], i);\n        }\n      }\n\n      atlas.clearDirty();\n    }\n  }\n\n  function load(glContext) {\n    gl = glContext;\n    utils = glUtils(glContext);\n\n    atlas = new WebglAtlas(tilesPerTexture);\n\n    program = utils.createProgram(nodesVS, nodesFS);\n    gl.useProgram(program);\n    locations = utils.getLocations(program, [\"a_vertexPos\", \"a_customAttributes\", \"u_screenSize\", \"u_transform\", \"u_sampler0\", \"u_sampler1\", \"u_sampler2\", \"u_sampler3\", \"u_tilesPerTexture\"]);\n\n    gl.uniform1f(locations.tilesPerTexture, tilesPerTexture);\n\n    gl.enableVertexAttribArray(locations.vertexPos);\n    gl.enableVertexAttribArray(locations.customAttributes);\n\n    buffer = gl.createBuffer();\n  }\n\n  function position(nodeUI, pos) {\n    var idx = nodeUI.id * ATTRIBUTES_PER_PRIMITIVE;\n    nodes[idx] = pos.x - nodeUI.size;\n    nodes[idx + 1] = -pos.y - nodeUI.size;\n    nodes[idx + 2] = nodeUI._offset * 4;\n\n    nodes[idx + 3] = pos.x + nodeUI.size;\n    nodes[idx + 4] = -pos.y - nodeUI.size;\n    nodes[idx + 5] = nodeUI._offset * 4 + 1;\n\n    nodes[idx + 6] = pos.x - nodeUI.size;\n    nodes[idx + 7] = -pos.y + nodeUI.size;\n    nodes[idx + 8] = nodeUI._offset * 4 + 2;\n\n    nodes[idx + 9] = pos.x - nodeUI.size;\n    nodes[idx + 10] = -pos.y + nodeUI.size;\n    nodes[idx + 11] = nodeUI._offset * 4 + 2;\n\n    nodes[idx + 12] = pos.x + nodeUI.size;\n    nodes[idx + 13] = -pos.y - nodeUI.size;\n    nodes[idx + 14] = nodeUI._offset * 4 + 1;\n\n    nodes[idx + 15] = pos.x + nodeUI.size;\n    nodes[idx + 16] = -pos.y + nodeUI.size;\n    nodes[idx + 17] = nodeUI._offset * 4 + 3;\n  }\n\n  function createNode(ui) {\n    nodes = utils.extendArray(nodes, nodesCount, ATTRIBUTES_PER_PRIMITIVE);\n    nodesCount += 1;\n\n    var coordinates = atlas.getCoordinates(ui.src);\n    if (coordinates) {\n      ui._offset = coordinates.offset;\n    } else {\n      ui._offset = 0;\n      // Image is not yet loaded into the atlas. Reload it:\n      atlas.load(ui.src, function(coordinates) {\n        ui._offset = coordinates.offset;\n      });\n    }\n  }\n\n  function removeNode(nodeUI) {\n    if (nodesCount > 0) {\n      nodesCount -= 1;\n    }\n\n    if (nodeUI.id < nodesCount && nodesCount > 0) {\n      if (nodeUI.src) {\n        atlas.remove(nodeUI.src);\n      }\n\n      utils.copyArrayPart(nodes, nodeUI.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n    }\n  }\n\n  function replaceProperties(replacedNode, newNode) {\n    newNode._offset = replacedNode._offset;\n  }\n\n  function updateTransform(newTransform) {\n    sizeDirty = true;\n    transform = newTransform;\n  }\n\n  function updateSize(w, h) {\n    width = w;\n    height = h;\n    sizeDirty = true;\n  }\n\n  function render() {\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, nodes, gl.DYNAMIC_DRAW);\n\n    if (sizeDirty) {\n      sizeDirty = false;\n      gl.uniformMatrix4fv(locations.transform, false, transform);\n      gl.uniform2f(locations.screenSize, width, height);\n    }\n\n    gl.vertexAttribPointer(locations.vertexPos, 2, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(locations.customAttributes, 1, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 2 * 4);\n\n    ensureAtlasTextureUpdated();\n\n    gl.drawArrays(gl.TRIANGLES, 0, nodesCount * 6);\n  }\n}\n\n// TODO: Use glslify for shaders\nfunction createNodeFragmentShader() {\n  return [\n    \"precision mediump float;\",\n    \"varying vec4 color;\",\n    \"varying vec3 vTextureCoord;\",\n    \"uniform sampler2D u_sampler0;\",\n    \"uniform sampler2D u_sampler1;\",\n    \"uniform sampler2D u_sampler2;\",\n    \"uniform sampler2D u_sampler3;\",\n\n    \"void main(void) {\",\n    \"   if (vTextureCoord.z == 0.) {\",\n    \"     gl_FragColor = texture2D(u_sampler0, vTextureCoord.xy);\",\n    \"   } else if (vTextureCoord.z == 1.) {\",\n    \"     gl_FragColor = texture2D(u_sampler1, vTextureCoord.xy);\",\n    \"   } else if (vTextureCoord.z == 2.) {\",\n    \"     gl_FragColor = texture2D(u_sampler2, vTextureCoord.xy);\",\n    \"   } else if (vTextureCoord.z == 3.) {\",\n    \"     gl_FragColor = texture2D(u_sampler3, vTextureCoord.xy);\",\n    \"   } else { gl_FragColor = vec4(0, 1, 0, 1); }\",\n    \"}\"\n  ].join(\"\\n\");\n}\n\nfunction createNodeVertexShader() {\n  return [\n    \"attribute vec2 a_vertexPos;\",\n\n    \"attribute float a_customAttributes;\",\n    \"uniform vec2 u_screenSize;\",\n    \"uniform mat4 u_transform;\",\n    \"uniform float u_tilesPerTexture;\",\n    \"varying vec3 vTextureCoord;\",\n\n    \"void main(void) {\",\n    \"   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0, 1);\",\n    \"float corner = mod(a_customAttributes, 4.);\",\n    \"float tileIndex = mod(floor(a_customAttributes / 4.), u_tilesPerTexture);\",\n    \"float tilesPerRow = sqrt(u_tilesPerTexture);\",\n    \"float tileSize = 1./tilesPerRow;\",\n    \"float tileColumn = mod(tileIndex, tilesPerRow);\",\n    \"float tileRow = floor(tileIndex/tilesPerRow);\",\n\n    \"if(corner == 0.0) {\",\n    \"  vTextureCoord.xy = vec2(0, 1);\",\n    \"} else if(corner == 1.0) {\",\n    \"  vTextureCoord.xy = vec2(1, 1);\",\n    \"} else if(corner == 2.0) {\",\n    \"  vTextureCoord.xy = vec2(0, 0);\",\n    \"} else {\",\n    \"  vTextureCoord.xy = vec2(1, 0);\",\n    \"}\",\n\n    \"vTextureCoord *= tileSize;\",\n    \"vTextureCoord.x += tileColumn * tileSize;\",\n    \"vTextureCoord.y += tileRow * tileSize;\",\n    \"vTextureCoord.z = floor(floor(a_customAttributes / 4.)/u_tilesPerTexture);\",\n    \"}\"\n  ].join(\"\\n\");\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}