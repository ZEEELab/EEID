{"ast":null,"code":"module.exports = betweennes;\n\n/**\n * I'm using http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf\n * as a reference for this implementation\n */\nfunction betweennes(graph, oriented) {\n  var Q = [],\n    S = []; // Queue and Stack\n  // list of predcessors on shorteest paths from source\n  var pred = Object.create(null);\n  // distance from source\n  var dist = Object.create(null);\n  // number of shortest paths from source to key\n  var sigma = Object.create(null);\n  // dependency of source on key\n  var delta = Object.create(null);\n  var currentNode;\n  var centrality = Object.create(null);\n  graph.forEachNode(setCentralityToZero);\n  graph.forEachNode(calculateCentrality);\n  if (!oriented) {\n    // The centrality scores need to be divided by two if the graph is not oriented,\n    // since all shortest paths are considered twice\n    Object.keys(centrality).forEach(divideByTwo);\n  }\n  return centrality;\n  function divideByTwo(key) {\n    centrality[key] /= 2;\n  }\n  function setCentralityToZero(node) {\n    centrality[node.id] = 0;\n  }\n  function calculateCentrality(node) {\n    currentNode = node.id;\n    singleSourceShortestPath(currentNode);\n    accumulate();\n  }\n  function accumulate() {\n    graph.forEachNode(setDeltaToZero);\n    while (S.length) {\n      var w = S.pop();\n      var coeff = (1 + delta[w]) / sigma[w];\n      var predcessors = pred[w];\n      for (var idx = 0; idx < predcessors.length; ++idx) {\n        var v = predcessors[idx];\n        delta[v] += sigma[v] * coeff;\n      }\n      if (w !== currentNode) {\n        centrality[w] += delta[w];\n      }\n    }\n  }\n  function setDeltaToZero(node) {\n    delta[node.id] = 0;\n  }\n  function singleSourceShortestPath(source) {\n    graph.forEachNode(initNode);\n    dist[source] = 0;\n    sigma[source] = 1;\n    Q.push(source);\n    while (Q.length) {\n      var v = Q.shift();\n      S.push(v);\n      graph.forEachLinkedNode(v, toId, oriented);\n    }\n    function toId(otherNode) {\n      // NOTE: This code will also consider multi-edges, which are often\n      // ignored by popular software (Gephi/NetworkX). Depending on your use\n      // case this may not be desired and deduping needs to be performed. To\n      // save memory I'm not deduping here...\n      processNode(otherNode.id);\n    }\n    function initNode(node) {\n      var nodeId = node.id;\n      pred[nodeId] = []; // empty list\n      dist[nodeId] = -1;\n      sigma[nodeId] = 0;\n    }\n    function processNode(w) {\n      // path discovery\n      if (dist[w] === -1) {\n        // Node w is found for the first time\n        dist[w] = dist[v] + 1;\n        Q.push(w);\n      }\n      // path counting\n      if (dist[w] === dist[v] + 1) {\n        // edge (v, w) on a shortest path\n        sigma[w] += sigma[v];\n        pred[w].push(v);\n      }\n    }\n  }\n}","map":{"version":3,"names":["module","exports","betweennes","graph","oriented","Q","S","pred","Object","create","dist","sigma","delta","currentNode","centrality","forEachNode","setCentralityToZero","calculateCentrality","keys","forEach","divideByTwo","key","node","id","singleSourceShortestPath","accumulate","setDeltaToZero","length","w","pop","coeff","predcessors","idx","v","source","initNode","push","shift","forEachLinkedNode","toId","otherNode","processNode","nodeId"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/ngraph.centrality/src/betweenness.js"],"sourcesContent":["module.exports = betweennes;\n\n/**\n * I'm using http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf\n * as a reference for this implementation\n */\nfunction betweennes(graph, oriented) {\n  var Q = [],\n    S = []; // Queue and Stack\n  // list of predcessors on shorteest paths from source\n  var pred = Object.create(null);\n  // distance from source\n  var dist = Object.create(null);\n  // number of shortest paths from source to key\n  var sigma = Object.create(null);\n  // dependency of source on key\n  var delta = Object.create(null);\n\n  var currentNode;\n  var centrality = Object.create(null);\n\n  graph.forEachNode(setCentralityToZero);\n  graph.forEachNode(calculateCentrality);\n\n  if (!oriented) {\n    // The centrality scores need to be divided by two if the graph is not oriented,\n    // since all shortest paths are considered twice\n    Object.keys(centrality).forEach(divideByTwo);\n  }\n\n  return centrality;\n\n  function divideByTwo(key) {\n    centrality[key] /= 2;\n  }\n\n  function setCentralityToZero(node) {\n    centrality[node.id] = 0;\n  }\n\n  function calculateCentrality(node) {\n    currentNode = node.id;\n    singleSourceShortestPath(currentNode);\n    accumulate();\n  }\n\n  function accumulate() {\n    graph.forEachNode(setDeltaToZero);\n    while (S.length) {\n      var w = S.pop();\n      var coeff = (1 + delta[w])/sigma[w];\n      var predcessors = pred[w];\n      for (var idx = 0; idx < predcessors.length; ++idx) {\n        var v = predcessors[idx];\n        delta[v] += sigma[v] * coeff;\n      }\n      if (w !== currentNode) {\n        centrality[w] += delta[w];\n      }\n    }\n  }\n\n  function setDeltaToZero(node) {\n    delta[node.id] = 0;\n  }\n\n  function singleSourceShortestPath(source) {\n    graph.forEachNode(initNode);\n    dist[source] = 0;\n    sigma[source] = 1;\n    Q.push(source);\n\n    while (Q.length) {\n      var v = Q.shift();\n      S.push(v);\n      graph.forEachLinkedNode(v, toId, oriented);\n    }\n\n    function toId(otherNode) {\n      // NOTE: This code will also consider multi-edges, which are often\n      // ignored by popular software (Gephi/NetworkX). Depending on your use\n      // case this may not be desired and deduping needs to be performed. To\n      // save memory I'm not deduping here...\n      processNode(otherNode.id);\n    }\n\n    function initNode(node) {\n      var nodeId = node.id;\n      pred[nodeId] = []; // empty list\n      dist[nodeId] = -1;\n      sigma[nodeId] = 0;\n    }\n\n    function processNode(w) {\n      // path discovery\n      if (dist[w] === -1) {\n        // Node w is found for the first time\n        dist[w] = dist[v] + 1;\n        Q.push(w);\n      }\n      // path counting\n      if (dist[w] === dist[v] + 1) {\n        // edge (v, w) on a shortest path\n        sigma[w] += sigma[v];\n        pred[w].push(v);\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}