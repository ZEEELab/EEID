{"ast":null,"code":"var Texture = require('./texture.js');\nmodule.exports = webglAtlas;\n\n/**\n * My naive implementation of textures atlas. It allows clients to load\n * multiple images into atlas and get canvas representing all of them.\n *\n * @param tilesPerTexture - indicates how many images can be loaded to one\n *          texture of the atlas. If number of loaded images exceeds this\n *          parameter a new canvas will be created.\n */\nfunction webglAtlas(tilesPerTexture) {\n  var tilesPerRow = Math.sqrt(tilesPerTexture || 1024) << 0,\n    tileSize = tilesPerRow,\n    lastLoadedIdx = 1,\n    loadedImages = {},\n    dirtyTimeoutId,\n    skipedDirty = 0,\n    textures = [],\n    trackedUrls = [];\n  if (!isPowerOf2(tilesPerTexture)) {\n    throw \"Tiles per texture should be power of two.\";\n  }\n\n  // this is the return object\n  var api = {\n    /**\n     * indicates whether atlas has changed texture in it. If true then\n     * some of the textures has isDirty flag set as well.\n     */\n    isDirty: false,\n    /**\n     * Clears any signs of atlas changes.\n     */\n    clearDirty: clearDirty,\n    /**\n     * Removes given url from collection of tiles in the atlas.\n     */\n    remove: remove,\n    /**\n     * Gets all textures in the atlas.\n     */\n    getTextures: getTextures,\n    /**\n     * Gets coordinates of the given image in the atlas. Coordinates is an object:\n     * {offset : int } - where offset is an absolute position of the image in the\n     * atlas.\n     *\n     * Absolute means it can be larger than tilesPerTexture parameter, and in that\n     * case clients should get next texture in getTextures() collection.\n     */\n    getCoordinates: getCoordinates,\n    /**\n     * Asynchronously Loads the image to the atlas. Cross-domain security\n     * limitation applies.\n     */\n    load: load\n  };\n  return api;\n  function clearDirty() {\n    var i;\n    api.isDirty = false;\n    for (i = 0; i < textures.length; ++i) {\n      textures[i].isDirty = false;\n    }\n  }\n  function remove(imgUrl) {\n    var coordinates = loadedImages[imgUrl];\n    if (!coordinates) {\n      return false;\n    }\n    delete loadedImages[imgUrl];\n    lastLoadedIdx -= 1;\n    if (lastLoadedIdx === coordinates.offset) {\n      return true; // Ignore if it's last image in the whole set.\n    }\n\n    var tileToRemove = getTileCoordinates(coordinates.offset),\n      lastTileInSet = getTileCoordinates(lastLoadedIdx);\n    copy(lastTileInSet, tileToRemove);\n    var replacedOffset = loadedImages[trackedUrls[lastLoadedIdx]];\n    replacedOffset.offset = coordinates.offset;\n    trackedUrls[coordinates.offset] = trackedUrls[lastLoadedIdx];\n    markDirty();\n    return true;\n  }\n  function getTextures() {\n    return textures; // I trust you...\n  }\n\n  function getCoordinates(imgUrl) {\n    return loadedImages[imgUrl];\n  }\n  function load(imgUrl, callback) {\n    if (loadedImages.hasOwnProperty(imgUrl)) {\n      callback(loadedImages[imgUrl]);\n    } else {\n      var img = new window.Image(),\n        imgId = lastLoadedIdx;\n      lastLoadedIdx += 1;\n      img.crossOrigin = \"anonymous\";\n      img.onload = function () {\n        markDirty();\n        drawAt(imgId, img, callback);\n      };\n      img.src = imgUrl;\n    }\n  }\n  function createTexture() {\n    var texture = new Texture(tilesPerRow * tileSize);\n    textures.push(texture);\n  }\n  function drawAt(tileNumber, img, callback) {\n    var tilePosition = getTileCoordinates(tileNumber),\n      coordinates = {\n        offset: tileNumber\n      };\n    if (tilePosition.textureNumber >= textures.length) {\n      createTexture();\n    }\n    var currentTexture = textures[tilePosition.textureNumber];\n    currentTexture.ctx.drawImage(img, tilePosition.col * tileSize, tilePosition.row * tileSize, tileSize, tileSize);\n    trackedUrls[tileNumber] = img.src;\n    loadedImages[img.src] = coordinates;\n    currentTexture.isDirty = true;\n    callback(coordinates);\n  }\n  function getTileCoordinates(absolutePosition) {\n    var textureNumber = absolutePosition / tilesPerTexture << 0,\n      localTileNumber = absolutePosition % tilesPerTexture,\n      row = localTileNumber / tilesPerRow << 0,\n      col = localTileNumber % tilesPerRow;\n    return {\n      textureNumber: textureNumber,\n      row: row,\n      col: col\n    };\n  }\n  function markDirtyNow() {\n    api.isDirty = true;\n    skipedDirty = 0;\n    dirtyTimeoutId = null;\n  }\n  function markDirty() {\n    // delay this call, since it results in texture reload\n    if (dirtyTimeoutId) {\n      window.clearTimeout(dirtyTimeoutId);\n      skipedDirty += 1;\n      dirtyTimeoutId = null;\n    }\n    if (skipedDirty > 10) {\n      markDirtyNow();\n    } else {\n      dirtyTimeoutId = window.setTimeout(markDirtyNow, 400);\n    }\n  }\n  function copy(from, to) {\n    var fromCanvas = textures[from.textureNumber].canvas,\n      toCtx = textures[to.textureNumber].ctx,\n      x = to.col * tileSize,\n      y = to.row * tileSize;\n    toCtx.drawImage(fromCanvas, from.col * tileSize, from.row * tileSize, tileSize, tileSize, x, y, tileSize, tileSize);\n    textures[from.textureNumber].isDirty = true;\n    textures[to.textureNumber].isDirty = true;\n  }\n}\nfunction isPowerOf2(n) {\n  return (n & n - 1) === 0;\n}","map":{"version":3,"names":["Texture","require","module","exports","webglAtlas","tilesPerTexture","tilesPerRow","Math","sqrt","tileSize","lastLoadedIdx","loadedImages","dirtyTimeoutId","skipedDirty","textures","trackedUrls","isPowerOf2","api","isDirty","clearDirty","remove","getTextures","getCoordinates","load","i","length","imgUrl","coordinates","offset","tileToRemove","getTileCoordinates","lastTileInSet","copy","replacedOffset","markDirty","callback","hasOwnProperty","img","window","Image","imgId","crossOrigin","onload","drawAt","src","createTexture","texture","push","tileNumber","tilePosition","textureNumber","currentTexture","ctx","drawImage","col","row","absolutePosition","localTileNumber","markDirtyNow","clearTimeout","setTimeout","from","to","fromCanvas","canvas","toCtx","x","y","n"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/vivagraphjs/src/WebGL/webglAtlas.js"],"sourcesContent":["var Texture = require('./texture.js');\n\nmodule.exports = webglAtlas;\n\n/**\n * My naive implementation of textures atlas. It allows clients to load\n * multiple images into atlas and get canvas representing all of them.\n *\n * @param tilesPerTexture - indicates how many images can be loaded to one\n *          texture of the atlas. If number of loaded images exceeds this\n *          parameter a new canvas will be created.\n */\nfunction webglAtlas(tilesPerTexture) {\n  var tilesPerRow = Math.sqrt(tilesPerTexture || 1024) << 0,\n    tileSize = tilesPerRow,\n    lastLoadedIdx = 1,\n    loadedImages = {},\n    dirtyTimeoutId,\n    skipedDirty = 0,\n    textures = [],\n    trackedUrls = [];\n\n  if (!isPowerOf2(tilesPerTexture)) {\n    throw \"Tiles per texture should be power of two.\";\n  }\n\n  // this is the return object\n  var api = {\n    /**\n     * indicates whether atlas has changed texture in it. If true then\n     * some of the textures has isDirty flag set as well.\n     */\n    isDirty: false,\n\n    /**\n     * Clears any signs of atlas changes.\n     */\n    clearDirty: clearDirty,\n\n    /**\n     * Removes given url from collection of tiles in the atlas.\n     */\n    remove: remove,\n\n    /**\n     * Gets all textures in the atlas.\n     */\n    getTextures: getTextures,\n\n    /**\n     * Gets coordinates of the given image in the atlas. Coordinates is an object:\n     * {offset : int } - where offset is an absolute position of the image in the\n     * atlas.\n     *\n     * Absolute means it can be larger than tilesPerTexture parameter, and in that\n     * case clients should get next texture in getTextures() collection.\n     */\n    getCoordinates: getCoordinates,\n\n    /**\n     * Asynchronously Loads the image to the atlas. Cross-domain security\n     * limitation applies.\n     */\n    load: load\n  };\n\n  return api;\n\n  function clearDirty() {\n    var i;\n    api.isDirty = false;\n    for (i = 0; i < textures.length; ++i) {\n      textures[i].isDirty = false;\n    }\n  }\n\n  function remove(imgUrl) {\n    var coordinates = loadedImages[imgUrl];\n    if (!coordinates) {\n      return false;\n    }\n    delete loadedImages[imgUrl];\n    lastLoadedIdx -= 1;\n\n\n    if (lastLoadedIdx === coordinates.offset) {\n      return true; // Ignore if it's last image in the whole set.\n    }\n\n    var tileToRemove = getTileCoordinates(coordinates.offset),\n      lastTileInSet = getTileCoordinates(lastLoadedIdx);\n\n    copy(lastTileInSet, tileToRemove);\n\n    var replacedOffset = loadedImages[trackedUrls[lastLoadedIdx]];\n    replacedOffset.offset = coordinates.offset;\n    trackedUrls[coordinates.offset] = trackedUrls[lastLoadedIdx];\n\n    markDirty();\n    return true;\n  }\n\n  function getTextures() {\n    return textures; // I trust you...\n  }\n\n  function getCoordinates(imgUrl) {\n    return loadedImages[imgUrl];\n  }\n\n  function load(imgUrl, callback) {\n    if (loadedImages.hasOwnProperty(imgUrl)) {\n      callback(loadedImages[imgUrl]);\n    } else {\n      var img = new window.Image(),\n        imgId = lastLoadedIdx;\n\n      lastLoadedIdx += 1;\n      img.crossOrigin = \"anonymous\";\n      img.onload = function() {\n        markDirty();\n        drawAt(imgId, img, callback);\n      };\n\n      img.src = imgUrl;\n    }\n  }\n\n  function createTexture() {\n    var texture = new Texture(tilesPerRow * tileSize);\n    textures.push(texture);\n  }\n\n  function drawAt(tileNumber, img, callback) {\n    var tilePosition = getTileCoordinates(tileNumber),\n      coordinates = {\n        offset: tileNumber\n      };\n\n    if (tilePosition.textureNumber >= textures.length) {\n      createTexture();\n    }\n    var currentTexture = textures[tilePosition.textureNumber];\n\n    currentTexture.ctx.drawImage(img, tilePosition.col * tileSize, tilePosition.row * tileSize, tileSize, tileSize);\n    trackedUrls[tileNumber] = img.src;\n\n    loadedImages[img.src] = coordinates;\n    currentTexture.isDirty = true;\n\n    callback(coordinates);\n  }\n\n  function getTileCoordinates(absolutePosition) {\n    var textureNumber = (absolutePosition / tilesPerTexture) << 0,\n      localTileNumber = (absolutePosition % tilesPerTexture),\n      row = (localTileNumber / tilesPerRow) << 0,\n      col = (localTileNumber % tilesPerRow);\n\n    return {\n      textureNumber: textureNumber,\n      row: row,\n      col: col\n    };\n  }\n\n  function markDirtyNow() {\n    api.isDirty = true;\n    skipedDirty = 0;\n    dirtyTimeoutId = null;\n  }\n\n  function markDirty() {\n    // delay this call, since it results in texture reload\n    if (dirtyTimeoutId) {\n      window.clearTimeout(dirtyTimeoutId);\n      skipedDirty += 1;\n      dirtyTimeoutId = null;\n    }\n\n    if (skipedDirty > 10) {\n      markDirtyNow();\n    } else {\n      dirtyTimeoutId = window.setTimeout(markDirtyNow, 400);\n    }\n  }\n\n  function copy(from, to) {\n    var fromCanvas = textures[from.textureNumber].canvas,\n      toCtx = textures[to.textureNumber].ctx,\n      x = to.col * tileSize,\n      y = to.row * tileSize;\n\n    toCtx.drawImage(fromCanvas, from.col * tileSize, from.row * tileSize, tileSize, tileSize, x, y, tileSize, tileSize);\n    textures[from.textureNumber].isDirty = true;\n    textures[to.textureNumber].isDirty = true;\n  }\n}\n\nfunction isPowerOf2(n) {\n  return (n & (n - 1)) === 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}