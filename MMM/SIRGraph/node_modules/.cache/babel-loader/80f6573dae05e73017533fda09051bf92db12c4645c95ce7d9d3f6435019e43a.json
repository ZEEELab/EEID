{"ast":null,"code":"/**\n * @fileOverview Defines a naive form of nodes for webglGraphics class.\n * This form allows to change color of node. Shape of nodes is rectangular.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nvar glUtils = require('./webgl.js');\nmodule.exports = webglNodeProgram;\n\n/**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as square. Color and size can be changed.\n */\nfunction webglNodeProgram() {\n  var ATTRIBUTES_PER_PRIMITIVE = 4; // Primitive is point, x, y, size, color\n  // x, y, z - floats, color = uint.\n  var BYTES_PER_NODE = 3 * Float32Array.BYTES_PER_ELEMENT + Uint32Array.BYTES_PER_ELEMENT;\n  var nodesFS = ['precision mediump float;', 'varying vec4 color;', 'void main(void) {', '   gl_FragColor = color;', '}'].join('\\n');\n  var nodesVS = ['attribute vec3 a_vertexPos;', 'attribute vec4 a_color;', 'uniform vec2 u_screenSize;', 'uniform mat4 u_transform;', 'varying vec4 color;', 'void main(void) {', '   gl_Position = u_transform * vec4(a_vertexPos.xy/u_screenSize, 0, 1);', '   gl_PointSize = a_vertexPos.z * u_transform[0][0];', '   color = a_color.abgr;', '}'].join('\\n');\n  var program;\n  var gl;\n  var buffer;\n  var locations;\n  var utils;\n  var storage = new ArrayBuffer(16 * BYTES_PER_NODE);\n  var positions = new Float32Array(storage);\n  var colors = new Uint32Array(storage);\n  var nodesCount = 0;\n  var width;\n  var height;\n  var transform;\n  var sizeDirty;\n  return {\n    load: load,\n    /**\n     * Updates position of node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n    position: position,\n    updateTransform: updateTransform,\n    updateSize: updateSize,\n    removeNode: removeNode,\n    createNode: createNode,\n    replaceProperties: replaceProperties,\n    render: render\n  };\n  function ensureEnoughStorage() {\n    if ((nodesCount + 1) * BYTES_PER_NODE >= storage.byteLength) {\n      // Every time we run out of space create new array twice bigger.\n      // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n      var extendedStorage = new ArrayBuffer(storage.byteLength * 2),\n        extendedPositions = new Float32Array(extendedStorage),\n        extendedColors = new Uint32Array(extendedStorage);\n      extendedColors.set(colors); // should be enough to copy just one view.\n      positions = extendedPositions;\n      colors = extendedColors;\n      storage = extendedStorage;\n    }\n  }\n  function load(glContext) {\n    gl = glContext;\n    utils = glUtils(glContext);\n    program = utils.createProgram(nodesVS, nodesFS);\n    gl.useProgram(program);\n    locations = utils.getLocations(program, ['a_vertexPos', 'a_color', 'u_screenSize', 'u_transform']);\n    gl.enableVertexAttribArray(locations.vertexPos);\n    gl.enableVertexAttribArray(locations.color);\n    buffer = gl.createBuffer();\n  }\n  function position(nodeUI, pos) {\n    var idx = nodeUI.id;\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE] = pos.x;\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE + 1] = -pos.y;\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE + 2] = nodeUI.size;\n    colors[idx * ATTRIBUTES_PER_PRIMITIVE + 3] = nodeUI.color;\n  }\n  function updateTransform(newTransform) {\n    sizeDirty = true;\n    transform = newTransform;\n  }\n  function updateSize(w, h) {\n    width = w;\n    height = h;\n    sizeDirty = true;\n  }\n  function removeNode(node) {\n    if (nodesCount > 0) {\n      nodesCount -= 1;\n    }\n    if (node.id < nodesCount && nodesCount > 0) {\n      // we can use colors as a 'view' into array array buffer.\n      utils.copyArrayPart(colors, node.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n    }\n  }\n  function createNode() {\n    ensureEnoughStorage();\n    nodesCount += 1;\n  }\n  function replaceProperties( /* replacedNode, newNode */) {}\n  function render() {\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, storage, gl.DYNAMIC_DRAW);\n    if (sizeDirty) {\n      sizeDirty = false;\n      gl.uniformMatrix4fv(locations.transform, false, transform);\n      gl.uniform2f(locations.screenSize, width, height);\n    }\n    gl.vertexAttribPointer(locations.vertexPos, 3, gl.FLOAT, false, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(locations.color, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 3 * 4);\n    gl.drawArrays(gl.POINTS, 0, nodesCount);\n  }\n}","map":{"version":3,"names":["glUtils","require","module","exports","webglNodeProgram","ATTRIBUTES_PER_PRIMITIVE","BYTES_PER_NODE","Float32Array","BYTES_PER_ELEMENT","Uint32Array","nodesFS","join","nodesVS","program","gl","buffer","locations","utils","storage","ArrayBuffer","positions","colors","nodesCount","width","height","transform","sizeDirty","load","position","updateTransform","updateSize","removeNode","createNode","replaceProperties","render","ensureEnoughStorage","byteLength","extendedStorage","extendedPositions","extendedColors","set","glContext","createProgram","useProgram","getLocations","enableVertexAttribArray","vertexPos","color","createBuffer","nodeUI","pos","idx","id","x","y","size","newTransform","w","h","node","copyArrayPart","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","uniformMatrix4fv","uniform2f","screenSize","vertexAttribPointer","FLOAT","UNSIGNED_BYTE","drawArrays","POINTS"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/vivagraphjs/src/WebGL/webglNodeProgram.js"],"sourcesContent":["/**\n * @fileOverview Defines a naive form of nodes for webglGraphics class.\n * This form allows to change color of node. Shape of nodes is rectangular.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nvar glUtils = require('./webgl.js');\n\nmodule.exports = webglNodeProgram;\n\n/**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as square. Color and size can be changed.\n */\nfunction webglNodeProgram() {\n  var ATTRIBUTES_PER_PRIMITIVE = 4; // Primitive is point, x, y, size, color\n  // x, y, z - floats, color = uint.\n  var BYTES_PER_NODE = 3 * Float32Array.BYTES_PER_ELEMENT + Uint32Array.BYTES_PER_ELEMENT;\n  var nodesFS = [\n    'precision mediump float;',\n    'varying vec4 color;',\n\n    'void main(void) {',\n    '   gl_FragColor = color;',\n    '}'\n  ].join('\\n');\n  var nodesVS = [\n    'attribute vec3 a_vertexPos;',\n    'attribute vec4 a_color;',\n    'uniform vec2 u_screenSize;',\n    'uniform mat4 u_transform;',\n    'varying vec4 color;',\n\n    'void main(void) {',\n    '   gl_Position = u_transform * vec4(a_vertexPos.xy/u_screenSize, 0, 1);',\n    '   gl_PointSize = a_vertexPos.z * u_transform[0][0];',\n    '   color = a_color.abgr;',\n    '}'\n  ].join('\\n');\n\n  var program;\n  var gl;\n  var buffer;\n  var locations;\n  var utils;\n  var storage = new ArrayBuffer(16 * BYTES_PER_NODE);\n  var positions = new Float32Array(storage);\n  var colors = new Uint32Array(storage);\n  var nodesCount = 0;\n  var width;\n  var height;\n  var transform;\n  var sizeDirty;\n\n  return {\n    load: load,\n\n    /**\n     * Updates position of node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n    position: position,\n\n    updateTransform: updateTransform,\n\n    updateSize: updateSize,\n\n    removeNode: removeNode,\n\n    createNode: createNode,\n\n    replaceProperties: replaceProperties,\n\n    render: render\n  };\n\n  function ensureEnoughStorage() {\n    if ((nodesCount + 1) * BYTES_PER_NODE >= storage.byteLength) {\n      // Every time we run out of space create new array twice bigger.\n      // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n      var extendedStorage = new ArrayBuffer(storage.byteLength * 2),\n        extendedPositions = new Float32Array(extendedStorage),\n        extendedColors = new Uint32Array(extendedStorage);\n\n      extendedColors.set(colors); // should be enough to copy just one view.\n      positions = extendedPositions;\n      colors = extendedColors;\n      storage = extendedStorage;\n    }\n  }\n\n  function load(glContext) {\n    gl = glContext;\n    utils = glUtils(glContext);\n\n    program = utils.createProgram(nodesVS, nodesFS);\n    gl.useProgram(program);\n    locations = utils.getLocations(program, ['a_vertexPos', 'a_color', 'u_screenSize', 'u_transform']);\n\n    gl.enableVertexAttribArray(locations.vertexPos);\n    gl.enableVertexAttribArray(locations.color);\n\n    buffer = gl.createBuffer();\n  }\n\n  function position(nodeUI, pos) {\n    var idx = nodeUI.id;\n\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE] = pos.x;\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE + 1] = -pos.y;\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE + 2] = nodeUI.size;\n\n    colors[idx * ATTRIBUTES_PER_PRIMITIVE + 3] = nodeUI.color;\n  }\n\n  function updateTransform(newTransform) {\n    sizeDirty = true;\n    transform = newTransform;\n  }\n\n  function updateSize(w, h) {\n    width = w;\n    height = h;\n    sizeDirty = true;\n  }\n\n  function removeNode(node) {\n      if (nodesCount > 0) {\n        nodesCount -= 1;\n      }\n\n      if (node.id < nodesCount && nodesCount > 0) {\n        // we can use colors as a 'view' into array array buffer.\n        utils.copyArrayPart(colors, node.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n      }\n    }\n\n  function createNode() {\n    ensureEnoughStorage();\n    nodesCount += 1;\n  }\n\n  function replaceProperties(/* replacedNode, newNode */) {}\n\n  function render() {\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, storage, gl.DYNAMIC_DRAW);\n\n    if (sizeDirty) {\n      sizeDirty = false;\n      gl.uniformMatrix4fv(locations.transform, false, transform);\n      gl.uniform2f(locations.screenSize, width, height);\n    }\n\n    gl.vertexAttribPointer(locations.vertexPos, 3, gl.FLOAT, false, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(locations.color, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 3 * 4);\n\n    gl.drawArrays(gl.POINTS, 0, nodesCount);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}