{"ast":null,"code":"module.exports = createLayout;\nmodule.exports.simulator = require('ngraph.physics.simulator');\nvar eventify = require('ngraph.events');\n\n/**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n  var createSimulator = require('ngraph.physics.simulator');\n  var physicsSimulator = createSimulator(physicsSettings);\n  var nodeMass = defaultNodeMass;\n  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n    nodeMass = physicsSettings.nodeMass;\n  }\n  var nodeBodies = Object.create(null);\n  var springs = {};\n  var bodiesCount = 0;\n  var springTransform = physicsSimulator.settings.springTransform || noop;\n\n  // Initialize physics with what we have in the graph:\n  initPhysics();\n  listenToEvents();\n  var wasStable = false;\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; Flase otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n    step: function () {\n      if (bodiesCount === 0) return true; // TODO: This will never fire 'stable'\n\n      var lastMove = physicsSimulator.step();\n\n      // Save the movement in case if someone wants to query it in the step\n      // callback.\n      api.lastMove = lastMove;\n\n      // Allow listeners to perform low-level actions after nodes are updated.\n      api.fire('step');\n      var ratio = lastMove / bodiesCount;\n      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n\n      if (wasStable !== isStableNow) {\n        wasStable = isStableNow;\n        onStableChanged(isStableNow);\n      }\n      return isStableNow;\n    },\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n      physicsSimulator.invalidateBBox();\n    },\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n    /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n    forEachBody: forEachBody,\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n      body.isPinned = !!isPinned;\n    },\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n    /**\n     * Request to release all resources\n     */\n    dispose: function () {\n      graph.off('changed', onGraphChanged);\n      api.fire('disposed');\n    },\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is trated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator,\n    /**\n     * Gets the graph that was used for layout\n     */\n    graph: graph,\n    /**\n     * Gets amount of movement performed during last step opeartion\n     */\n    lastMove: 0\n  };\n  eventify(api);\n  return api;\n  function forEachBody(cb) {\n    Object.keys(nodeBodies).forEach(function (bodyId) {\n      cb(nodeBodies[bodyId], bodyId);\n    });\n  }\n  function getSpring(fromId, toId) {\n    var linkId;\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n    return springs[linkId];\n  }\n  function getBody(nodeId) {\n    return nodeBodies[nodeId];\n  }\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n  }\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n    bodiesCount = graph.getNodesCount();\n  }\n  function initPhysics() {\n    bodiesCount = 0;\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n      bodiesCount += 1;\n    });\n    graph.forEachLink(initLink);\n  }\n  function initBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      var node = graph.getNode(nodeId);\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n      var pos = node.position;\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n      body = physicsSimulator.addBodyAt(pos);\n      body.id = nodeId;\n      nodeBodies[nodeId] = body;\n      updateBodyMass(nodeId);\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies[nodeId];\n    if (body) {\n      nodeBodies[nodeId] = null;\n      delete nodeBodies[nodeId];\n      physicsSimulator.removeBody(body);\n    }\n  }\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n    var fromBody = nodeBodies[link.fromId],\n      toBody = nodeBodies[link.toId],\n      spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n    springTransform(link, spring);\n    springs[link.id] = spring;\n  }\n  function releaseLink(link) {\n    var spring = springs[link.id];\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n        to = graph.getNode(link.toId);\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n      delete springs[link.id];\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n    if (!node.links) {\n      return neighbors;\n    }\n    var maxNeighbors = Math.min(node.links.length, 2);\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies[link.fromId] : nodeBodies[link.toId];\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n    return neighbors;\n  }\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies[nodeId];\n    body.mass = nodeMass(nodeId);\n    if (Number.isNaN(body.mass)) {\n      throw new Error('Node mass should be a number');\n    }\n  }\n\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be preconfigured\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n  function isNodeOriginallyPinned(node) {\n    return node && (node.isPinned || node.data && node.data.isPinned);\n  }\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies[nodeId];\n    }\n    return body;\n  }\n\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n  function defaultNodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n}\nfunction noop() {}","map":{"version":3,"names":["module","exports","createLayout","simulator","require","eventify","graph","physicsSettings","Error","createSimulator","physicsSimulator","nodeMass","defaultNodeMass","nodeBodies","Object","create","springs","bodiesCount","springTransform","settings","noop","initPhysics","listenToEvents","wasStable","api","step","lastMove","fire","ratio","isStableNow","onStableChanged","getNodePosition","nodeId","getInitializedBody","pos","setNodePosition","body","setPosition","apply","Array","prototype","slice","call","arguments","invalidateBBox","getLinkPosition","linkId","spring","from","to","getGraphRect","getBBox","forEachBody","pinNode","node","isPinned","id","isNodePinned","dispose","off","onGraphChanged","getBody","getSpring","cb","keys","forEach","bodyId","fromId","toId","undefined","link","hasLink","on","isStable","changes","i","length","change","changeType","initBody","initLink","releaseNode","releaseLink","getNodesCount","forEachNode","forEachLink","getNode","position","neighbors","getNeighborBodies","getBestNewBodyPosition","addBodyAt","updateBodyMass","isNodeOriginallyPinned","removeBody","fromBody","toBody","addSpring","removeSpring","links","maxNeighbors","Math","min","otherBody","push","mass","Number","isNaN","data","getLinks"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/ngraph.forcelayout/index.js"],"sourcesContent":["module.exports = createLayout;\nmodule.exports.simulator = require('ngraph.physics.simulator');\n\nvar eventify = require('ngraph.events');\n\n/**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n\n  var createSimulator = require('ngraph.physics.simulator');\n  var physicsSimulator = createSimulator(physicsSettings);\n\n  var nodeMass = defaultNodeMass\n  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n    nodeMass = physicsSettings.nodeMass\n  }\n\n  var nodeBodies = Object.create(null);\n  var springs = {};\n  var bodiesCount = 0;\n\n  var springTransform = physicsSimulator.settings.springTransform || noop;\n\n  // Initialize physics with what we have in the graph:\n  initPhysics();\n  listenToEvents();\n\n  var wasStable = false;\n\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; Flase otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n    step: function() {\n      if (bodiesCount === 0) return true; // TODO: This will never fire 'stable'\n\n      var lastMove = physicsSimulator.step();\n\n      // Save the movement in case if someone wants to query it in the step\n      // callback.\n      api.lastMove = lastMove;\n\n      // Allow listeners to perform low-level actions after nodes are updated.\n      api.fire('step');\n\n      var ratio = lastMove/bodiesCount;\n      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n\n      if (wasStable !== isStableNow) {\n        wasStable = isStableNow;\n        onStableChanged(isStableNow);\n      }\n\n      return isStableNow;\n    },\n\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n      physicsSimulator.invalidateBBox();\n    },\n\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n\n    /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n    forEachBody: forEachBody,\n\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n       body.isPinned = !!isPinned;\n    },\n\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n\n    /**\n     * Request to release all resources\n     */\n    dispose: function() {\n      graph.off('changed', onGraphChanged);\n      api.fire('disposed');\n    },\n\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is trated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator,\n\n    /**\n     * Gets the graph that was used for layout\n     */\n    graph: graph,\n\n    /**\n     * Gets amount of movement performed during last step opeartion\n     */\n    lastMove: 0\n  };\n\n  eventify(api);\n\n  return api;\n\n  function forEachBody(cb) {\n    Object.keys(nodeBodies).forEach(function(bodyId) {\n      cb(nodeBodies[bodyId], bodyId);\n    });\n  }\n\n  function getSpring(fromId, toId) {\n    var linkId;\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n\n    return springs[linkId];\n  }\n\n  function getBody(nodeId) {\n    return nodeBodies[nodeId];\n  }\n\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n  }\n\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n    bodiesCount = graph.getNodesCount();\n  }\n\n  function initPhysics() {\n    bodiesCount = 0;\n\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n      bodiesCount += 1;\n    });\n\n    graph.forEachLink(initLink);\n  }\n\n  function initBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      var node = graph.getNode(nodeId);\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n\n      var pos = node.position;\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n\n      body = physicsSimulator.addBodyAt(pos);\n      body.id = nodeId;\n\n      nodeBodies[nodeId] = body;\n      updateBodyMass(nodeId);\n\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies[nodeId];\n    if (body) {\n      nodeBodies[nodeId] = null;\n      delete nodeBodies[nodeId];\n\n      physicsSimulator.removeBody(body);\n    }\n  }\n\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n\n    var fromBody = nodeBodies[link.fromId],\n        toBody  = nodeBodies[link.toId],\n        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n\n    springTransform(link, spring);\n\n    springs[link.id] = spring;\n  }\n\n  function releaseLink(link) {\n    var spring = springs[link.id];\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n          to = graph.getNode(link.toId);\n\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n\n      delete springs[link.id];\n\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n    if (!node.links) {\n      return neighbors;\n    }\n    var maxNeighbors = Math.min(node.links.length, 2);\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies[link.fromId] : nodeBodies[link.toId];\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n\n    return neighbors;\n  }\n\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies[nodeId];\n    body.mass = nodeMass(nodeId);\n    if (Number.isNaN(body.mass)) {\n      throw new Error('Node mass should be a number')\n    }\n  }\n\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be preconfigured\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n  function isNodeOriginallyPinned(node) {\n    return (node && (node.isPinned || (node.data && node.data.isPinned)));\n  }\n\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies[nodeId];\n    }\n    return body;\n  }\n\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n  function defaultNodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n}\n\nfunction noop() { }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}