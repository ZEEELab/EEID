{"ast":null,"code":"module.exports = constant;\nvar merge = require('ngraph.merge');\nvar random = require('ngraph.random').random;\nvar Rect = require('../Utils/rect.js');\n\n/**\n * Does not really perform any layouting algorithm but is compliant\n * with renderer interface. Allowing clients to provide specific positioning\n * callback and get static layout of the graph\n *\n * @param {Viva.Graph.graph} graph to layout\n * @param {Object} userSettings\n */\nfunction constant(graph, userSettings) {\n  userSettings = merge(userSettings, {\n    maxX: 1024,\n    maxY: 1024,\n    seed: 'Deterministic randomness made me do this'\n  });\n  // This class simply follows API, it does not use some of the arguments:\n  /*jshint unused: false */\n  var rand = random(userSettings.seed),\n    graphRect = new Rect(Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE),\n    layoutLinks = {},\n    placeNodeCallback = function (node) {\n      return {\n        x: rand.next(userSettings.maxX),\n        y: rand.next(userSettings.maxY)\n      };\n    },\n    updateGraphRect = function (position, graphRect) {\n      if (position.x < graphRect.x1) {\n        graphRect.x1 = position.x;\n      }\n      if (position.x > graphRect.x2) {\n        graphRect.x2 = position.x;\n      }\n      if (position.y < graphRect.y1) {\n        graphRect.y1 = position.y;\n      }\n      if (position.y > graphRect.y2) {\n        graphRect.y2 = position.y;\n      }\n    },\n    layoutNodes = typeof Object.create === 'function' ? Object.create(null) : {},\n    ensureNodeInitialized = function (node) {\n      layoutNodes[node.id] = placeNodeCallback(node);\n      updateGraphRect(layoutNodes[node.id], graphRect);\n    },\n    updateNodePositions = function () {\n      if (graph.getNodesCount() === 0) {\n        return;\n      }\n      graphRect.x1 = Number.MAX_VALUE;\n      graphRect.y1 = Number.MAX_VALUE;\n      graphRect.x2 = Number.MIN_VALUE;\n      graphRect.y2 = Number.MIN_VALUE;\n      graph.forEachNode(ensureNodeInitialized);\n    },\n    ensureLinkInitialized = function (link) {\n      layoutLinks[link.id] = link;\n    },\n    onGraphChanged = function (changes) {\n      for (var i = 0; i < changes.length; ++i) {\n        var change = changes[i];\n        if (change.node) {\n          if (change.changeType === 'add') {\n            ensureNodeInitialized(change.node);\n          } else {\n            delete layoutNodes[change.node.id];\n          }\n        }\n        if (change.link) {\n          if (change.changeType === 'add') {\n            ensureLinkInitialized(change.link);\n          } else {\n            delete layoutLinks[change.link.id];\n          }\n        }\n      }\n    };\n  graph.forEachNode(ensureNodeInitialized);\n  graph.forEachLink(ensureLinkInitialized);\n  graph.on('changed', onGraphChanged);\n  return {\n    /**\n     * Attempts to layout graph within given number of iterations.\n     *\n     * @param {integer} [iterationsCount] number of algorithm's iterations.\n     *  The constant layout ignores this parameter.\n     */\n    run: function (iterationsCount) {\n      this.step();\n    },\n    /**\n     * One step of layout algorithm.\n     */\n    step: function () {\n      updateNodePositions();\n      return true; // no need to continue.\n    },\n\n    /**\n     * Returns rectangle structure {x1, y1, x2, y2}, which represents\n     * current space occupied by graph.\n     */\n    getGraphRect: function () {\n      return graphRect;\n    },\n    /**\n     * Request to release all resources\n     */\n    dispose: function () {\n      graph.off('change', onGraphChanged);\n    },\n    /*\n     * Checks whether given node is pinned; all nodes in this layout are pinned.\n     */\n    isNodePinned: function (node) {\n      return true;\n    },\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      // noop\n    },\n    /*\n     * Gets position of a node by its id. If node was not seen by this\n     * layout algorithm undefined value is returned;\n     */\n    getNodePosition: getNodePosition,\n    /**\n     * Returns {from, to} position of a link.\n     */\n    getLinkPosition: function (linkId) {\n      var link = layoutLinks[linkId];\n      return {\n        from: getNodePosition(link.fromId),\n        to: getNodePosition(link.toId)\n      };\n    },\n    /**\n     * Sets position of a node to a given coordinates\n     */\n    setNodePosition: function (nodeId, x, y) {\n      var pos = layoutNodes[nodeId];\n      if (pos) {\n        pos.x = x;\n        pos.y = y;\n      }\n    },\n    // Layout specific methods:\n\n    /**\n     * Based on argument either update default node placement callback or\n     * attempts to place given node using current placement callback.\n     * Setting new node callback triggers position update for all nodes.\n     *\n     * @param {Object} newPlaceNodeCallbackOrNode - if it is a function then\n     * default node placement callback is replaced with new one. Node placement\n     * callback has a form of function (node) {}, and is expected to return an\n     * object with x and y properties set to numbers.\n     *\n     * Otherwise if it's not a function the argument is treated as graph node\n     * and current node placement callback will be used to place it.\n     */\n    placeNode: function (newPlaceNodeCallbackOrNode) {\n      if (typeof newPlaceNodeCallbackOrNode === 'function') {\n        placeNodeCallback = newPlaceNodeCallbackOrNode;\n        updateNodePositions();\n        return this;\n      }\n\n      // it is not a request to update placeNodeCallback, trying to place\n      // a node using current callback:\n      return placeNodeCallback(newPlaceNodeCallbackOrNode);\n    }\n  };\n  function getNodePosition(nodeId) {\n    return layoutNodes[nodeId];\n  }\n}","map":{"version":3,"names":["module","exports","constant","merge","require","random","Rect","graph","userSettings","maxX","maxY","seed","rand","graphRect","Number","MAX_VALUE","MIN_VALUE","layoutLinks","placeNodeCallback","node","x","next","y","updateGraphRect","position","x1","x2","y1","y2","layoutNodes","Object","create","ensureNodeInitialized","id","updateNodePositions","getNodesCount","forEachNode","ensureLinkInitialized","link","onGraphChanged","changes","i","length","change","changeType","forEachLink","on","run","iterationsCount","step","getGraphRect","dispose","off","isNodePinned","pinNode","isPinned","getNodePosition","getLinkPosition","linkId","from","fromId","to","toId","setNodePosition","nodeId","pos","placeNode","newPlaceNodeCallbackOrNode"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/vivagraphjs/src/Layout/constant.js"],"sourcesContent":["module.exports = constant;\n\nvar merge = require('ngraph.merge');\nvar random = require('ngraph.random').random;\nvar Rect = require('../Utils/rect.js');\n\n/**\n * Does not really perform any layouting algorithm but is compliant\n * with renderer interface. Allowing clients to provide specific positioning\n * callback and get static layout of the graph\n *\n * @param {Viva.Graph.graph} graph to layout\n * @param {Object} userSettings\n */\nfunction constant(graph, userSettings) {\n    userSettings = merge(userSettings, {\n        maxX : 1024,\n        maxY : 1024,\n        seed : 'Deterministic randomness made me do this'\n    });\n    // This class simply follows API, it does not use some of the arguments:\n    /*jshint unused: false */\n    var rand = random(userSettings.seed),\n        graphRect = new Rect(Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE),\n        layoutLinks = {},\n\n        placeNodeCallback = function (node) {\n            return {\n              x: rand.next(userSettings.maxX),\n              y: rand.next(userSettings.maxY)\n            };\n        },\n\n        updateGraphRect = function (position, graphRect) {\n            if (position.x < graphRect.x1) { graphRect.x1 = position.x; }\n            if (position.x > graphRect.x2) { graphRect.x2 = position.x; }\n            if (position.y < graphRect.y1) { graphRect.y1 = position.y; }\n            if (position.y > graphRect.y2) { graphRect.y2 = position.y; }\n        },\n\n        layoutNodes = typeof Object.create === 'function' ? Object.create(null) : {},\n\n        ensureNodeInitialized = function (node) {\n            layoutNodes[node.id] = placeNodeCallback(node);\n            updateGraphRect(layoutNodes[node.id], graphRect);\n        },\n\n        updateNodePositions = function () {\n            if (graph.getNodesCount() === 0) { return; }\n\n            graphRect.x1 = Number.MAX_VALUE;\n            graphRect.y1 = Number.MAX_VALUE;\n            graphRect.x2 = Number.MIN_VALUE;\n            graphRect.y2 = Number.MIN_VALUE;\n\n            graph.forEachNode(ensureNodeInitialized);\n        },\n\n        ensureLinkInitialized = function (link) {\n          layoutLinks[link.id] = link;\n        },\n\n        onGraphChanged = function(changes) {\n            for (var i = 0; i < changes.length; ++i) {\n                var change = changes[i];\n                if (change.node) {\n                    if (change.changeType === 'add') {\n                        ensureNodeInitialized(change.node);\n                    } else {\n                        delete layoutNodes[change.node.id];\n                    }\n                } if (change.link) {\n                    if (change.changeType === 'add') {\n                        ensureLinkInitialized(change.link);\n                    } else {\n                        delete layoutLinks[change.link.id];\n                    }\n                }\n            }\n        };\n\n    graph.forEachNode(ensureNodeInitialized);\n    graph.forEachLink(ensureLinkInitialized);\n    graph.on('changed', onGraphChanged);\n\n    return {\n        /**\n         * Attempts to layout graph within given number of iterations.\n         *\n         * @param {integer} [iterationsCount] number of algorithm's iterations.\n         *  The constant layout ignores this parameter.\n         */\n        run : function (iterationsCount) {\n            this.step();\n        },\n\n        /**\n         * One step of layout algorithm.\n         */\n        step : function () {\n            updateNodePositions();\n\n            return true; // no need to continue.\n        },\n\n        /**\n         * Returns rectangle structure {x1, y1, x2, y2}, which represents\n         * current space occupied by graph.\n         */\n        getGraphRect : function () {\n            return graphRect;\n        },\n\n        /**\n         * Request to release all resources\n         */\n        dispose : function () {\n            graph.off('change', onGraphChanged);\n        },\n\n        /*\n         * Checks whether given node is pinned; all nodes in this layout are pinned.\n         */\n        isNodePinned: function (node) {\n            return true;\n        },\n\n        /*\n         * Requests layout algorithm to pin/unpin node to its current position\n         * Pinned nodes should not be affected by layout algorithm and always\n         * remain at their position\n         */\n        pinNode: function (node, isPinned) {\n           // noop\n        },\n\n        /*\n         * Gets position of a node by its id. If node was not seen by this\n         * layout algorithm undefined value is returned;\n         */\n        getNodePosition: getNodePosition,\n\n        /**\n         * Returns {from, to} position of a link.\n         */\n        getLinkPosition: function (linkId) {\n          var link = layoutLinks[linkId];\n          return {\n              from : getNodePosition(link.fromId),\n              to : getNodePosition(link.toId)\n          };\n        },\n\n        /**\n         * Sets position of a node to a given coordinates\n         */\n        setNodePosition: function (nodeId, x, y) {\n            var pos = layoutNodes[nodeId];\n            if (pos) {\n                pos.x = x;\n                pos.y = y;\n            }\n        },\n\n        // Layout specific methods:\n\n        /**\n         * Based on argument either update default node placement callback or\n         * attempts to place given node using current placement callback.\n         * Setting new node callback triggers position update for all nodes.\n         *\n         * @param {Object} newPlaceNodeCallbackOrNode - if it is a function then\n         * default node placement callback is replaced with new one. Node placement\n         * callback has a form of function (node) {}, and is expected to return an\n         * object with x and y properties set to numbers.\n         *\n         * Otherwise if it's not a function the argument is treated as graph node\n         * and current node placement callback will be used to place it.\n         */\n        placeNode : function (newPlaceNodeCallbackOrNode) {\n            if (typeof newPlaceNodeCallbackOrNode === 'function') {\n                placeNodeCallback = newPlaceNodeCallbackOrNode;\n                updateNodePositions();\n                return this;\n            }\n\n            // it is not a request to update placeNodeCallback, trying to place\n            // a node using current callback:\n            return placeNodeCallback(newPlaceNodeCallbackOrNode);\n        }\n\n    };\n\n    function getNodePosition(nodeId) {\n        return layoutNodes[nodeId];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}