{"ast":null,"code":"/**\r\n * @fileOverview Defines a graph renderer that uses WebGL based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\n\nmodule.exports = webglGraphics;\nvar webglInputManager = require('../Input/webglInputManager.js');\nvar webglLinkProgram = require('../WebGL/webglLinkProgram.js');\nvar webglNodeProgram = require('../WebGL/webglNodeProgram.js');\nvar webglSquare = require('../WebGL/webglSquare.js');\nvar webglLine = require('../WebGL/webglLine.js');\nvar eventify = require('ngraph.events');\nvar merge = require('ngraph.merge');\n\n/**\r\n * Performs webgl-based graph rendering. This module does not perform\r\n * layout, but only visualizes nodes and edges of the graph.\r\n *\r\n * @param options - to customize graphics  behavior. Currently supported parameter\r\n *  enableBlending - true by default, allows to use transparency in node/links colors.\r\n *  preserveDrawingBuffer - false by default, tells webgl to preserve drawing buffer.\r\n *                    See https://www.khronos.org/registry/webgl/specs/1.0/#5.2\r\n */\n\nfunction webglGraphics(options) {\n  options = merge(options, {\n    enableBlending: true,\n    preserveDrawingBuffer: false,\n    clearColor: false,\n    clearColorValue: {\n      r: 1,\n      g: 1,\n      b: 1,\n      a: 1\n    }\n  });\n  var container,\n    graphicsRoot,\n    gl,\n    width,\n    height,\n    nodesCount = 0,\n    linksCount = 0,\n    transform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n    userPlaceNodeCallback,\n    userPlaceLinkCallback,\n    nodes = [],\n    links = [],\n    initCallback,\n    allNodes = {},\n    allLinks = {},\n    linkProgram = webglLinkProgram(),\n    nodeProgram = webglNodeProgram(),\n    /*jshint unused: false */\n    nodeUIBuilder = function (node) {\n      return webglSquare(); // Just make a square, using provided gl context (a nodeProgram);\n    },\n    linkUIBuilder = function (link) {\n      return webglLine(0xb3b3b3ff);\n    },\n    /*jshint unused: true */\n    updateTransformUniform = function () {\n      linkProgram.updateTransform(transform);\n      nodeProgram.updateTransform(transform);\n    },\n    resetScaleInternal = function () {\n      transform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    },\n    updateSize = function () {\n      if (container && graphicsRoot) {\n        width = graphicsRoot.width = Math.max(container.offsetWidth, 1);\n        height = graphicsRoot.height = Math.max(container.offsetHeight, 1);\n        if (gl) {\n          gl.viewport(0, 0, width, height);\n        }\n        if (linkProgram) {\n          linkProgram.updateSize(width / 2, height / 2);\n        }\n        if (nodeProgram) {\n          nodeProgram.updateSize(width / 2, height / 2);\n        }\n      }\n    },\n    fireRescaled = function (graphics) {\n      graphics.fire(\"rescaled\");\n    };\n  graphicsRoot = window.document.createElement(\"canvas\");\n  var graphics = {\n    getLinkUI: function (linkId) {\n      return allLinks[linkId];\n    },\n    getNodeUI: function (nodeId) {\n      return allNodes[nodeId];\n    },\n    /**\r\n     * Sets the callback that creates node representation.\r\n     *\r\n     * @param builderCallback a callback function that accepts graph node\r\n     * as a parameter and must return an element representing this node.\r\n     *\r\n     * @returns If builderCallbackOrNode is a valid callback function, instance of this is returned;\r\n     * Otherwise undefined value is returned\r\n     */\n    node: function (builderCallback) {\n      if (typeof builderCallback !== \"function\") {\n        return; // todo: throw? This is not compatible with old versions\n      }\n\n      nodeUIBuilder = builderCallback;\n      return this;\n    },\n    /**\r\n     * Sets the callback that creates link representation\r\n     *\r\n     * @param builderCallback a callback function that accepts graph link\r\n     * as a parameter and must return an element representing this link.\r\n     *\r\n     * @returns If builderCallback is a valid callback function, instance of this is returned;\r\n     * Otherwise undefined value is returned.\r\n     */\n    link: function (builderCallback) {\n      if (typeof builderCallback !== \"function\") {\n        return; // todo: throw? This is not compatible with old versions\n      }\n\n      linkUIBuilder = builderCallback;\n      return this;\n    },\n    /**\r\n     * Allows to override default position setter for the node with a new\r\n     * function. newPlaceCallback(nodeUI, position) is function which\r\n     * is used by updateNodePosition().\r\n     */\n    placeNode: function (newPlaceCallback) {\n      userPlaceNodeCallback = newPlaceCallback;\n      return this;\n    },\n    placeLink: function (newPlaceLinkCallback) {\n      userPlaceLinkCallback = newPlaceLinkCallback;\n      return this;\n    },\n    /**\r\n     * Custom input manager listens to mouse events to process nodes drag-n-drop inside WebGL canvas\r\n     */\n    inputManager: webglInputManager,\n    /**\r\n     * Called every time before renderer starts rendering.\r\n     */\n    beginRender: function () {\n      // this function could be replaced by this.init,\n      // based on user options.\n    },\n    /**\r\n     * Called every time when renderer finishes one step of rendering.\r\n     */\n    endRender: function () {\n      if (linksCount > 0) {\n        linkProgram.render();\n      }\n      if (nodesCount > 0) {\n        nodeProgram.render();\n      }\n    },\n    bringLinkToFront: function (linkUI) {\n      var frontLinkId = linkProgram.getFrontLinkId(),\n        srcLinkId,\n        temp;\n      linkProgram.bringToFront(linkUI);\n      if (frontLinkId > linkUI.id) {\n        srcLinkId = linkUI.id;\n        temp = links[frontLinkId];\n        links[frontLinkId] = links[srcLinkId];\n        links[frontLinkId].id = frontLinkId;\n        links[srcLinkId] = temp;\n        links[srcLinkId].id = srcLinkId;\n      }\n    },\n    /**\r\n     * Sets translate operation that should be applied to all nodes and links.\r\n     */\n    graphCenterChanged: function (x, y) {\n      transform[12] = 2 * x / width - 1;\n      transform[13] = 1 - 2 * y / height;\n      updateTransformUniform();\n    },\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider prepare to render given link of the graph\r\n     *\r\n     * @param link - model of a link\r\n     */\n    addLink: function (link, boundPosition) {\n      var uiid = linksCount++,\n        ui = linkUIBuilder(link);\n      ui.id = uiid;\n      ui.pos = boundPosition;\n      linkProgram.createLink(ui);\n      links[uiid] = ui;\n      allLinks[link.id] = ui;\n      return ui;\n    },\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider prepare to render given node of the graph.\r\n     *\r\n     * @param nodeUI visual representation of the node created by node() execution.\r\n     **/\n    addNode: function (node, boundPosition) {\n      var uiid = nodesCount++,\n        ui = nodeUIBuilder(node);\n      ui.id = uiid;\n      ui.position = boundPosition;\n      ui.node = node;\n      nodeProgram.createNode(ui);\n      nodes[uiid] = ui;\n      allNodes[node.id] = ui;\n      return ui;\n    },\n    translateRel: function (dx, dy) {\n      transform[12] += 2 * transform[0] * dx / width / transform[0];\n      transform[13] -= 2 * transform[5] * dy / height / transform[5];\n      updateTransformUniform();\n    },\n    scale: function (scaleFactor, scrollPoint) {\n      // Transform scroll point to clip-space coordinates:\n      var cx = 2 * scrollPoint.x / width - 1,\n        cy = 1 - 2 * scrollPoint.y / height;\n      cx -= transform[12];\n      cy -= transform[13];\n      transform[12] += cx * (1 - scaleFactor);\n      transform[13] += cy * (1 - scaleFactor);\n      transform[0] *= scaleFactor;\n      transform[5] *= scaleFactor;\n      updateTransformUniform();\n      fireRescaled(this);\n      return transform[0];\n    },\n    resetScale: function () {\n      resetScaleInternal();\n      if (gl) {\n        updateSize();\n        // TODO: what is this?\n        // gl.useProgram(linksProgram);\n        // gl.uniform2f(linksProgram.screenSize, width, height);\n        updateTransformUniform();\n      }\n      return this;\n    },\n    /**\r\n     * Resizes the graphic without resetting the scale. \r\n     * Useful with viva graph in a dynamic container\r\n     */\n    updateSize: updateSize,\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider prepare to render.\r\n     */\n    init: function (c) {\n      var contextParameters = {};\n      if (options.preserveDrawingBuffer) {\n        contextParameters.preserveDrawingBuffer = true;\n      }\n      container = c;\n      updateSize();\n      resetScaleInternal();\n      container.appendChild(graphicsRoot);\n      gl = graphicsRoot.getContext(\"experimental-webgl\", contextParameters);\n      if (!gl) {\n        var msg = \"Could not initialize WebGL. Seems like the browser doesn't support it.\";\n        window.alert(msg);\n        throw msg;\n      }\n      if (options.enableBlending) {\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n      }\n      if (options.clearColor) {\n        var color = options.clearColorValue;\n        gl.clearColor(color.r, color.g, color.b, color.a);\n        // TODO: not the best way, really. Should come up with something better\n        // what if we need more updates inside beginRender, like depth buffer?\n        this.beginRender = function () {\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        };\n      }\n      linkProgram.load(gl);\n      linkProgram.updateSize(width / 2, height / 2);\n      nodeProgram.load(gl);\n      nodeProgram.updateSize(width / 2, height / 2);\n      updateTransformUniform();\n\n      // Notify the world if someone waited for update. TODO: should send an event\n      if (typeof initCallback === \"function\") {\n        initCallback(graphicsRoot);\n      }\n    },\n    /**\r\n    * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n    * provider release occupied resources.\r\n    */\n    release: function (container) {\n      if (graphicsRoot && container) {\n        container.removeChild(graphicsRoot);\n        // TODO: anything else?\n      }\n    },\n\n    /**\r\n     * Checks whether webgl is supported by this browser.\r\n     */\n    isSupported: function () {\n      var c = window.document.createElement(\"canvas\"),\n        gl = c && c.getContext && c.getContext(\"experimental-webgl\");\n      return gl;\n    },\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider remove link from rendering surface.\r\n     *\r\n     * @param linkUI visual representation of the link created by link() execution.\r\n     **/\n    releaseLink: function (link) {\n      if (linksCount > 0) {\n        linksCount -= 1;\n      }\n      var linkUI = allLinks[link.id];\n      delete allLinks[link.id];\n      linkProgram.removeLink(linkUI);\n      var linkIdToRemove = linkUI.id;\n      if (linkIdToRemove < linksCount) {\n        if (linksCount === 0 || linksCount === linkIdToRemove) {\n          return; // no more links or removed link is the last one.\n        }\n\n        var lastLinkUI = links[linksCount];\n        links[linkIdToRemove] = lastLinkUI;\n        lastLinkUI.id = linkIdToRemove;\n      }\n    },\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider remove node from rendering surface.\r\n     *\r\n     * @param nodeUI visual representation of the node created by node() execution.\r\n     **/\n    releaseNode: function (node) {\n      if (nodesCount > 0) {\n        nodesCount -= 1;\n      }\n      var nodeUI = allNodes[node.id];\n      delete allNodes[node.id];\n      nodeProgram.removeNode(nodeUI);\n      var nodeIdToRemove = nodeUI.id;\n      if (nodeIdToRemove < nodesCount) {\n        if (nodesCount === 0 || nodesCount === nodeIdToRemove) {\n          return; // no more nodes or removed node is the last in the list.\n        }\n\n        var lastNodeUI = nodes[nodesCount];\n        nodes[nodeIdToRemove] = lastNodeUI;\n        lastNodeUI.id = nodeIdToRemove;\n\n        // Since concrete shaders may cache properties in the UI element\n        // we are letting them to make this swap (e.g. image node shader\n        // uses this approach to update node's offset in the atlas)\n        nodeProgram.replaceProperties(nodeUI, lastNodeUI);\n      }\n    },\n    renderNodes: function () {\n      var pos = {\n        x: 0,\n        y: 0\n      };\n      // WebGL coordinate system is different. Would be better\n      // to have this transform in the shader code, but it would\n      // require every shader to be updated..\n      for (var i = 0; i < nodesCount; ++i) {\n        var ui = nodes[i];\n        pos.x = ui.position.x;\n        pos.y = ui.position.y;\n        if (userPlaceNodeCallback) {\n          userPlaceNodeCallback(ui, pos);\n        }\n        nodeProgram.position(ui, pos);\n      }\n    },\n    renderLinks: function () {\n      if (this.omitLinksRendering) {\n        return;\n      }\n      var toPos = {\n        x: 0,\n        y: 0\n      };\n      var fromPos = {\n        x: 0,\n        y: 0\n      };\n      for (var i = 0; i < linksCount; ++i) {\n        var ui = links[i];\n        var pos = ui.pos.from;\n        fromPos.x = pos.x;\n        fromPos.y = -pos.y;\n        pos = ui.pos.to;\n        toPos.x = pos.x;\n        toPos.y = -pos.y;\n        if (userPlaceLinkCallback) {\n          userPlaceLinkCallback(ui, fromPos, toPos);\n        }\n        linkProgram.position(ui, fromPos, toPos);\n      }\n    },\n    /**\r\n     * Returns root element which hosts graphics.\r\n     */\n    getGraphicsRoot: function (callbackWhenReady) {\n      // todo: should fire an event, instead of having this context.\n      if (typeof callbackWhenReady === \"function\") {\n        if (graphicsRoot) {\n          callbackWhenReady(graphicsRoot);\n        } else {\n          initCallback = callbackWhenReady;\n        }\n      }\n      return graphicsRoot;\n    },\n    /**\r\n     * Updates default shader which renders nodes\r\n     *\r\n     * @param newProgram to use for nodes.\r\n     */\n    setNodeProgram: function (newProgram) {\n      if (!gl && newProgram) {\n        // Nothing created yet. Just set shader to the new one\n        // and let initialization logic take care about the rest.\n        nodeProgram = newProgram;\n      } else if (newProgram) {\n        throw \"Not implemented. Cannot swap shader on the fly... Yet.\";\n        // TODO: unload old shader and reinit.\n      }\n    },\n\n    /**\r\n     * Updates default shader which renders links\r\n     *\r\n     * @param newProgram to use for links.\r\n     */\n    setLinkProgram: function (newProgram) {\n      if (!gl && newProgram) {\n        // Nothing created yet. Just set shader to the new one\n        // and let initialization logic take care about the rest.\n        linkProgram = newProgram;\n      } else if (newProgram) {\n        throw \"Not implemented. Cannot swap shader on the fly... Yet.\";\n        // TODO: unload old shader and reinit.\n      }\n    },\n\n    /**\r\n     * Transforms client coordinates into layout coordinates. Client coordinates\r\n     * are DOM coordinates relative to the rendering container. Layout\r\n     * coordinates are those assigned by by layout algorithm to each node.\r\n     *\r\n     * @param {Object} p - a point object with `x` and `y` attributes.\r\n     * This method mutates p.\r\n     */\n    transformClientToGraphCoordinates: function (p) {\n      // TODO: could be a problem when container has margins?\n      // normalize\n      p.x = 2 * p.x / width - 1;\n      p.y = 1 - 2 * p.y / height;\n\n      // apply transform\n      p.x = (p.x - transform[12]) / transform[0];\n      p.y = (p.y - transform[13]) / transform[5];\n\n      // transform to graph coordinates\n      p.x = p.x * (width / 2);\n      p.y = p.y * (-height / 2);\n      return p;\n    },\n    /**\r\n     * Transforms WebGL coordinates into client coordinates. Reverse of \r\n     * `transformClientToGraphCoordinates()`\r\n     *\r\n     * @param {Object} p - a point object with `x` and `y` attributes, which\r\n     * represents a layout coordinate. This method mutates p.\r\n     */\n    transformGraphToClientCoordinates: function (p) {\n      // TODO: could be a problem when container has margins?\n      // transform from graph coordinates\n      p.x = p.x / (width / 2);\n      p.y = p.y / (-height / 2);\n\n      // apply transform\n      p.x = p.x * transform[0] + transform[12];\n      p.y = p.y * transform[5] + transform[13];\n\n      // denormalize\n      p.x = (p.x + 1) * width / 2;\n      p.y = (1 - p.y) * height / 2;\n      return p;\n    },\n    getNodeAtClientPos: function (clientPos, preciseCheck) {\n      if (typeof preciseCheck !== \"function\") {\n        // we don't know anything about your node structure here :(\n        // potentially this could be delegated to node program, but for\n        // right now, we are giving up if you don't pass boundary check\n        // callback. It answers to a question is nodeUI covers  (x, y)\n        return null;\n      }\n      // first transform to graph coordinates:\n      this.transformClientToGraphCoordinates(clientPos);\n      // now using precise check iterate over each node and find one within box:\n      // TODO: This is poor O(N) performance.\n      for (var i = 0; i < nodesCount; ++i) {\n        if (preciseCheck(nodes[i], clientPos.x, clientPos.y)) {\n          return nodes[i].node;\n        }\n      }\n      return null;\n    }\n  };\n\n  // Let graphics fire events before we return it to the caller.\n  eventify(graphics);\n  return graphics;\n}","map":{"version":3,"names":["module","exports","webglGraphics","webglInputManager","require","webglLinkProgram","webglNodeProgram","webglSquare","webglLine","eventify","merge","options","enableBlending","preserveDrawingBuffer","clearColor","clearColorValue","r","g","b","a","container","graphicsRoot","gl","width","height","nodesCount","linksCount","transform","userPlaceNodeCallback","userPlaceLinkCallback","nodes","links","initCallback","allNodes","allLinks","linkProgram","nodeProgram","nodeUIBuilder","node","linkUIBuilder","link","updateTransformUniform","updateTransform","resetScaleInternal","updateSize","Math","max","offsetWidth","offsetHeight","viewport","fireRescaled","graphics","fire","window","document","createElement","getLinkUI","linkId","getNodeUI","nodeId","builderCallback","placeNode","newPlaceCallback","placeLink","newPlaceLinkCallback","inputManager","beginRender","endRender","render","bringLinkToFront","linkUI","frontLinkId","getFrontLinkId","srcLinkId","temp","bringToFront","id","graphCenterChanged","x","y","addLink","boundPosition","uiid","ui","pos","createLink","addNode","position","createNode","translateRel","dx","dy","scale","scaleFactor","scrollPoint","cx","cy","resetScale","init","c","contextParameters","appendChild","getContext","msg","alert","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","enable","BLEND","color","clear","COLOR_BUFFER_BIT","load","release","removeChild","isSupported","releaseLink","removeLink","linkIdToRemove","lastLinkUI","releaseNode","nodeUI","removeNode","nodeIdToRemove","lastNodeUI","replaceProperties","renderNodes","i","renderLinks","omitLinksRendering","toPos","fromPos","from","to","getGraphicsRoot","callbackWhenReady","setNodeProgram","newProgram","setLinkProgram","transformClientToGraphCoordinates","p","transformGraphToClientCoordinates","getNodeAtClientPos","clientPos","preciseCheck"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/vivagraphjs/src/View/webglGraphics.js"],"sourcesContent":["/**\r\n * @fileOverview Defines a graph renderer that uses WebGL based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\r\n\r\nmodule.exports = webglGraphics;\r\n\r\nvar webglInputManager = require('../Input/webglInputManager.js');\r\nvar webglLinkProgram = require('../WebGL/webglLinkProgram.js');\r\nvar webglNodeProgram = require('../WebGL/webglNodeProgram.js');\r\nvar webglSquare = require('../WebGL/webglSquare.js');\r\nvar webglLine = require('../WebGL/webglLine.js');\r\nvar eventify = require('ngraph.events');\r\nvar merge = require('ngraph.merge');\r\n\r\n/**\r\n * Performs webgl-based graph rendering. This module does not perform\r\n * layout, but only visualizes nodes and edges of the graph.\r\n *\r\n * @param options - to customize graphics  behavior. Currently supported parameter\r\n *  enableBlending - true by default, allows to use transparency in node/links colors.\r\n *  preserveDrawingBuffer - false by default, tells webgl to preserve drawing buffer.\r\n *                    See https://www.khronos.org/registry/webgl/specs/1.0/#5.2\r\n */\r\n\r\nfunction webglGraphics(options) {\r\n    options = merge(options, {\r\n        enableBlending : true,\r\n        preserveDrawingBuffer : false,\r\n        clearColor: false,\r\n        clearColorValue : {\r\n            r : 1,\r\n            g : 1,\r\n            b : 1,\r\n            a : 1\r\n        }\r\n    });\r\n\r\n    var container,\r\n        graphicsRoot,\r\n        gl,\r\n        width,\r\n        height,\r\n        nodesCount = 0,\r\n        linksCount = 0,\r\n        transform = [\r\n            1, 0, 0, 0,\r\n            0, 1, 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1\r\n        ],\r\n        userPlaceNodeCallback,\r\n        userPlaceLinkCallback,\r\n        nodes = [],\r\n        links = [],\r\n        initCallback,\r\n\r\n        allNodes = {},\r\n        allLinks = {},\r\n        linkProgram = webglLinkProgram(),\r\n        nodeProgram = webglNodeProgram(),\r\n/*jshint unused: false */\r\n        nodeUIBuilder = function (node) {\r\n            return webglSquare(); // Just make a square, using provided gl context (a nodeProgram);\r\n        },\r\n\r\n        linkUIBuilder = function (link) {\r\n            return webglLine(0xb3b3b3ff);\r\n        },\r\n/*jshint unused: true */\r\n        updateTransformUniform = function () {\r\n            linkProgram.updateTransform(transform);\r\n            nodeProgram.updateTransform(transform);\r\n        },\r\n\r\n        resetScaleInternal = function () {\r\n            transform = [1, 0, 0, 0,\r\n                        0, 1, 0, 0,\r\n                        0, 0, 1, 0,\r\n                        0, 0, 0, 1];\r\n        },\r\n\r\n        updateSize = function () {\r\n            if (container && graphicsRoot) {\r\n                width = graphicsRoot.width = Math.max(container.offsetWidth, 1);\r\n                height = graphicsRoot.height = Math.max(container.offsetHeight, 1);\r\n                if (gl) { gl.viewport(0, 0, width, height); }\r\n                if (linkProgram) { linkProgram.updateSize(width / 2, height / 2); }\r\n                if (nodeProgram) { nodeProgram.updateSize(width / 2, height / 2); }\r\n            }\r\n        },\r\n\r\n        fireRescaled = function (graphics) {\r\n            graphics.fire(\"rescaled\");\r\n        };\r\n\r\n    graphicsRoot = window.document.createElement(\"canvas\");\r\n\r\n    var graphics = {\r\n        getLinkUI: function (linkId) {\r\n            return allLinks[linkId];\r\n        },\r\n\r\n        getNodeUI: function (nodeId) {\r\n            return allNodes[nodeId];\r\n        },\r\n\r\n        /**\r\n         * Sets the callback that creates node representation.\r\n         *\r\n         * @param builderCallback a callback function that accepts graph node\r\n         * as a parameter and must return an element representing this node.\r\n         *\r\n         * @returns If builderCallbackOrNode is a valid callback function, instance of this is returned;\r\n         * Otherwise undefined value is returned\r\n         */\r\n        node : function (builderCallback) {\r\n            if (typeof builderCallback !== \"function\") {\r\n                return; // todo: throw? This is not compatible with old versions\r\n            }\r\n\r\n            nodeUIBuilder = builderCallback;\r\n\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Sets the callback that creates link representation\r\n         *\r\n         * @param builderCallback a callback function that accepts graph link\r\n         * as a parameter and must return an element representing this link.\r\n         *\r\n         * @returns If builderCallback is a valid callback function, instance of this is returned;\r\n         * Otherwise undefined value is returned.\r\n         */\r\n        link : function (builderCallback) {\r\n            if (typeof builderCallback !== \"function\") {\r\n                return; // todo: throw? This is not compatible with old versions\r\n            }\r\n\r\n            linkUIBuilder = builderCallback;\r\n            return this;\r\n        },\r\n\r\n\r\n        /**\r\n         * Allows to override default position setter for the node with a new\r\n         * function. newPlaceCallback(nodeUI, position) is function which\r\n         * is used by updateNodePosition().\r\n         */\r\n        placeNode : function (newPlaceCallback) {\r\n            userPlaceNodeCallback = newPlaceCallback;\r\n            return this;\r\n        },\r\n\r\n        placeLink : function (newPlaceLinkCallback) {\r\n            userPlaceLinkCallback = newPlaceLinkCallback;\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Custom input manager listens to mouse events to process nodes drag-n-drop inside WebGL canvas\r\n         */\r\n        inputManager : webglInputManager,\r\n\r\n        /**\r\n         * Called every time before renderer starts rendering.\r\n         */\r\n        beginRender : function () {\r\n            // this function could be replaced by this.init,\r\n            // based on user options.\r\n        },\r\n\r\n        /**\r\n         * Called every time when renderer finishes one step of rendering.\r\n         */\r\n        endRender : function () {\r\n            if (linksCount > 0) {\r\n                linkProgram.render();\r\n            }\r\n            if (nodesCount > 0) {\r\n                nodeProgram.render();\r\n            }\r\n        },\r\n\r\n        bringLinkToFront : function (linkUI) {\r\n            var frontLinkId = linkProgram.getFrontLinkId(),\r\n                srcLinkId,\r\n                temp;\r\n\r\n            linkProgram.bringToFront(linkUI);\r\n\r\n            if (frontLinkId > linkUI.id) {\r\n                srcLinkId = linkUI.id;\r\n\r\n                temp = links[frontLinkId];\r\n                links[frontLinkId] = links[srcLinkId];\r\n                links[frontLinkId].id = frontLinkId;\r\n                links[srcLinkId] = temp;\r\n                links[srcLinkId].id = srcLinkId;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets translate operation that should be applied to all nodes and links.\r\n         */\r\n        graphCenterChanged : function (x, y) {\r\n            transform[12] = (2 * x / width) - 1;\r\n            transform[13] = 1 - (2 * y / height);\r\n            updateTransformUniform();\r\n        },\r\n\r\n        /**\r\n         * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n         * provider prepare to render given link of the graph\r\n         *\r\n         * @param link - model of a link\r\n         */\r\n        addLink: function (link, boundPosition) {\r\n            var uiid = linksCount++,\r\n                ui = linkUIBuilder(link);\r\n            ui.id = uiid;\r\n            ui.pos = boundPosition;\r\n\r\n            linkProgram.createLink(ui);\r\n\r\n            links[uiid] = ui;\r\n            allLinks[link.id] = ui;\r\n            return ui;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider prepare to render given node of the graph.\r\n        *\r\n        * @param nodeUI visual representation of the node created by node() execution.\r\n        **/\r\n        addNode : function (node, boundPosition) {\r\n            var uiid = nodesCount++,\r\n                ui = nodeUIBuilder(node);\r\n\r\n            ui.id = uiid;\r\n            ui.position = boundPosition;\r\n            ui.node = node;\r\n\r\n            nodeProgram.createNode(ui);\r\n\r\n            nodes[uiid] = ui;\r\n            allNodes[node.id] = ui;\r\n            return ui;\r\n        },\r\n\r\n        translateRel : function (dx, dy) {\r\n            transform[12] += (2 * transform[0] * dx / width) / transform[0];\r\n            transform[13] -= (2 * transform[5] * dy / height) / transform[5];\r\n            updateTransformUniform();\r\n        },\r\n\r\n        scale : function (scaleFactor, scrollPoint) {\r\n            // Transform scroll point to clip-space coordinates:\r\n            var cx = 2 * scrollPoint.x / width - 1,\r\n                cy = 1 - (2 * scrollPoint.y) / height;\r\n\r\n            cx -= transform[12];\r\n            cy -= transform[13];\r\n\r\n            transform[12] += cx * (1 - scaleFactor);\r\n            transform[13] += cy * (1 - scaleFactor);\r\n\r\n            transform[0] *= scaleFactor;\r\n            transform[5] *= scaleFactor;\r\n\r\n            updateTransformUniform();\r\n            fireRescaled(this);\r\n\r\n            return transform[0];\r\n        },\r\n\r\n        resetScale : function () {\r\n            resetScaleInternal();\r\n\r\n            if (gl) {\r\n                updateSize();\r\n                // TODO: what is this?\r\n                // gl.useProgram(linksProgram);\r\n                // gl.uniform2f(linksProgram.screenSize, width, height);\r\n                updateTransformUniform();\r\n            }\r\n            return this;\r\n        },\r\n\r\n       /**\r\n        * Resizes the graphic without resetting the scale. \r\n        * Useful with viva graph in a dynamic container\r\n        */\r\n        updateSize: updateSize,\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider prepare to render.\r\n        */\r\n        init : function (c) {\r\n            var contextParameters = {};\r\n\r\n            if (options.preserveDrawingBuffer) {\r\n                contextParameters.preserveDrawingBuffer = true;\r\n            }\r\n\r\n            container = c;\r\n\r\n            updateSize();\r\n            resetScaleInternal();\r\n            container.appendChild(graphicsRoot);\r\n\r\n\r\n            gl = graphicsRoot.getContext(\"experimental-webgl\", contextParameters);\r\n            if (!gl) {\r\n                var msg = \"Could not initialize WebGL. Seems like the browser doesn't support it.\";\r\n                window.alert(msg);\r\n                throw msg;\r\n            }\r\n            if (options.enableBlending) {\r\n                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n                gl.enable(gl.BLEND);\r\n            }\r\n            if (options.clearColor) {\r\n                var color = options.clearColorValue;\r\n                gl.clearColor(color.r, color.g, color.b, color.a);\r\n                // TODO: not the best way, really. Should come up with something better\r\n                // what if we need more updates inside beginRender, like depth buffer?\r\n                this.beginRender = function () {\r\n                    gl.clear(gl.COLOR_BUFFER_BIT);\r\n                };\r\n            }\r\n\r\n            linkProgram.load(gl);\r\n            linkProgram.updateSize(width / 2, height / 2);\r\n\r\n            nodeProgram.load(gl);\r\n            nodeProgram.updateSize(width / 2, height / 2);\r\n\r\n            updateTransformUniform();\r\n\r\n            // Notify the world if someone waited for update. TODO: should send an event\r\n            if (typeof initCallback === \"function\") {\r\n                initCallback(graphicsRoot);\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider release occupied resources.\r\n        */\r\n        release : function (container) {\r\n            if (graphicsRoot && container) {\r\n                container.removeChild(graphicsRoot);\r\n                // TODO: anything else?\r\n            }\r\n        },\r\n\r\n       /**\r\n        * Checks whether webgl is supported by this browser.\r\n        */\r\n        isSupported : function () {\r\n            var c = window.document.createElement(\"canvas\"),\r\n                gl = c && c.getContext && c.getContext(\"experimental-webgl\");\r\n            return gl;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider remove link from rendering surface.\r\n        *\r\n        * @param linkUI visual representation of the link created by link() execution.\r\n        **/\r\n        releaseLink : function (link) {\r\n            if (linksCount > 0) { linksCount -= 1; }\r\n            var linkUI = allLinks[link.id];\r\n            delete allLinks[link.id];\r\n\r\n            linkProgram.removeLink(linkUI);\r\n\r\n            var linkIdToRemove = linkUI.id;\r\n            if (linkIdToRemove < linksCount) {\r\n                if (linksCount === 0 || linksCount === linkIdToRemove) {\r\n                    return; // no more links or removed link is the last one.\r\n                }\r\n\r\n                var lastLinkUI = links[linksCount];\r\n                links[linkIdToRemove] = lastLinkUI;\r\n                lastLinkUI.id = linkIdToRemove;\r\n            }\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider remove node from rendering surface.\r\n        *\r\n        * @param nodeUI visual representation of the node created by node() execution.\r\n        **/\r\n        releaseNode : function (node) {\r\n            if (nodesCount > 0) { nodesCount -= 1; }\r\n            var nodeUI = allNodes[node.id];\r\n            delete allNodes[node.id];\r\n\r\n            nodeProgram.removeNode(nodeUI);\r\n\r\n            var nodeIdToRemove = nodeUI.id;\r\n            if (nodeIdToRemove < nodesCount) {\r\n                if (nodesCount === 0 || nodesCount === nodeIdToRemove) {\r\n                    return; // no more nodes or removed node is the last in the list.\r\n                }\r\n\r\n                var lastNodeUI = nodes[nodesCount];\r\n\r\n                nodes[nodeIdToRemove] = lastNodeUI;\r\n                lastNodeUI.id = nodeIdToRemove;\r\n\r\n                // Since concrete shaders may cache properties in the UI element\r\n                // we are letting them to make this swap (e.g. image node shader\r\n                // uses this approach to update node's offset in the atlas)\r\n                nodeProgram.replaceProperties(nodeUI, lastNodeUI);\r\n            }\r\n        },\r\n\r\n        renderNodes: function () {\r\n            var pos = {x : 0, y : 0};\r\n            // WebGL coordinate system is different. Would be better\r\n            // to have this transform in the shader code, but it would\r\n            // require every shader to be updated..\r\n            for (var i = 0; i < nodesCount; ++i) {\r\n                var ui = nodes[i];\r\n                pos.x = ui.position.x;\r\n                pos.y = ui.position.y;\r\n                if (userPlaceNodeCallback) {\r\n                    userPlaceNodeCallback(ui, pos);\r\n                }\r\n\r\n                nodeProgram.position(ui, pos);\r\n            }\r\n        },\r\n\r\n        renderLinks: function () {\r\n            if (this.omitLinksRendering) { return; }\r\n\r\n            var toPos = {x : 0, y : 0};\r\n            var fromPos = {x : 0, y : 0};\r\n            for (var i = 0; i < linksCount; ++i) {\r\n                var ui = links[i];\r\n                var pos = ui.pos.from;\r\n                fromPos.x = pos.x;\r\n                fromPos.y = -pos.y;\r\n                pos = ui.pos.to;\r\n                toPos.x = pos.x;\r\n                toPos.y = -pos.y;\r\n                if (userPlaceLinkCallback) {\r\n                    userPlaceLinkCallback(ui, fromPos, toPos);\r\n                }\r\n\r\n                linkProgram.position(ui, fromPos, toPos);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns root element which hosts graphics.\r\n         */\r\n        getGraphicsRoot : function (callbackWhenReady) {\r\n            // todo: should fire an event, instead of having this context.\r\n            if (typeof callbackWhenReady === \"function\") {\r\n                if (graphicsRoot) {\r\n                    callbackWhenReady(graphicsRoot);\r\n                } else {\r\n                    initCallback = callbackWhenReady;\r\n                }\r\n            }\r\n            return graphicsRoot;\r\n        },\r\n\r\n        /**\r\n         * Updates default shader which renders nodes\r\n         *\r\n         * @param newProgram to use for nodes.\r\n         */\r\n        setNodeProgram : function (newProgram) {\r\n            if (!gl && newProgram) {\r\n                // Nothing created yet. Just set shader to the new one\r\n                // and let initialization logic take care about the rest.\r\n                nodeProgram = newProgram;\r\n            } else if (newProgram) {\r\n                throw \"Not implemented. Cannot swap shader on the fly... Yet.\";\r\n                // TODO: unload old shader and reinit.\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Updates default shader which renders links\r\n         *\r\n         * @param newProgram to use for links.\r\n         */\r\n        setLinkProgram : function (newProgram) {\r\n            if (!gl && newProgram) {\r\n                // Nothing created yet. Just set shader to the new one\r\n                // and let initialization logic take care about the rest.\r\n                linkProgram = newProgram;\r\n            } else if (newProgram) {\r\n                throw \"Not implemented. Cannot swap shader on the fly... Yet.\";\r\n                // TODO: unload old shader and reinit.\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Transforms client coordinates into layout coordinates. Client coordinates\r\n         * are DOM coordinates relative to the rendering container. Layout\r\n         * coordinates are those assigned by by layout algorithm to each node.\r\n         *\r\n         * @param {Object} p - a point object with `x` and `y` attributes.\r\n         * This method mutates p.\r\n         */\r\n        transformClientToGraphCoordinates: function (p) {\r\n          // TODO: could be a problem when container has margins?\r\n            // normalize\r\n            p.x = ((2 * p.x) / width) - 1;\r\n            p.y = 1 - ((2 * p.y) / height);\r\n\r\n            // apply transform\r\n            p.x = (p.x - transform[12]) / transform[0];\r\n            p.y = (p.y - transform[13]) / transform[5];\r\n\r\n            // transform to graph coordinates\r\n            p.x = p.x * (width / 2);\r\n            p.y = p.y * (-height / 2);\r\n\r\n            return p;\r\n        },\r\n\r\n        /**\r\n         * Transforms WebGL coordinates into client coordinates. Reverse of \r\n         * `transformClientToGraphCoordinates()`\r\n         *\r\n         * @param {Object} p - a point object with `x` and `y` attributes, which\r\n         * represents a layout coordinate. This method mutates p.\r\n         */\r\n        transformGraphToClientCoordinates: function (p) {\r\n          // TODO: could be a problem when container has margins?\r\n            // transform from graph coordinates\r\n            p.x = p.x / (width / 2);\r\n            p.y = p.y / (-height / 2);\r\n\r\n            // apply transform\r\n            p.x = (p.x * transform[0]) + transform[12];\r\n            p.y = (p.y * transform[5]) + transform[13];\r\n\r\n            // denormalize\r\n            p.x = ((p.x + 1) * width) / 2;\r\n            p.y = ((1 - p.y) * height) / 2;\r\n\r\n            return p;\r\n        },\r\n\r\n        getNodeAtClientPos: function (clientPos, preciseCheck) {\r\n            if (typeof preciseCheck !== \"function\") {\r\n                // we don't know anything about your node structure here :(\r\n                // potentially this could be delegated to node program, but for\r\n                // right now, we are giving up if you don't pass boundary check\r\n                // callback. It answers to a question is nodeUI covers  (x, y)\r\n                return null;\r\n            }\r\n            // first transform to graph coordinates:\r\n            this.transformClientToGraphCoordinates(clientPos);\r\n            // now using precise check iterate over each node and find one within box:\r\n            // TODO: This is poor O(N) performance.\r\n            for (var i = 0; i < nodesCount; ++i) {\r\n                if (preciseCheck(nodes[i], clientPos.x, clientPos.y)) {\r\n                    return nodes[i].node;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n\r\n    // Let graphics fire events before we return it to the caller.\r\n    eventify(graphics);\r\n\r\n    return graphics;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}