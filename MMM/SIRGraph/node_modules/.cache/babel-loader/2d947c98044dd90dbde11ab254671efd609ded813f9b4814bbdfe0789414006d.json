{"ast":null,"code":"/**\r\n * @fileOverview Defines a graph renderer that uses CSS based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\n\nmodule.exports = renderer;\nvar eventify = require('ngraph.events');\nvar forceDirected = require('ngraph.forcelayout');\nvar svgGraphics = require('./svgGraphics.js');\nvar windowEvents = require('../Utils/windowEvents.js');\nvar domInputManager = require('../Input/domInputManager.js');\nvar timer = require('../Utils/timer.js');\nvar getDimension = require('../Utils/getDimensions.js');\nvar dragndrop = require('../Input/dragndrop.js');\n\n/**\r\n * This is heart of the rendering. Class accepts graph to be rendered and rendering settings.\r\n * It monitors graph changes and depicts them accordingly.\r\n *\r\n * @param graph - Viva.Graph.graph() object to be rendered.\r\n * @param settings - rendering settings, composed from the following parts (with their defaults shown):\r\n *   settings = {\r\n *     // Represents a module that is capable of displaying graph nodes and links.\r\n *     // all graphics has to correspond to defined interface and can be later easily\r\n *     // replaced for specific needs (e.g. adding WebGL should be piece of cake as long\r\n *     // as WebGL has implemented required interface). See svgGraphics for example.\r\n *     graphics : Viva.Graph.View.svgGraphics(),\r\n *\r\n *     // Where the renderer should draw graph. Container size matters, because\r\n *     // renderer will attempt center graph to that size. Also graphics modules\r\n *     // might depend on it.\r\n *     container : document.body,\r\n *\r\n *     // Defines whether graph can respond to use input\r\n *     interactive: true,\r\n *\r\n *     // Layout algorithm to be used. The algorithm is expected to comply with defined\r\n *     // interface and is expected to be iterative. Renderer will use it then to calculate\r\n *     // graph's layout. For examples of the interface refer to Viva.Graph.Layout.forceDirected()\r\n *     layout : Viva.Graph.Layout.forceDirected(),\r\n *\r\n *     // Directs renderer to display links. Usually rendering links is the slowest part of this\r\n *     // library. So if you don't need to display links, consider settings this property to false.\r\n *     renderLinks : true,\r\n *\r\n *     // Number of layout iterations to run before displaying the graph. The bigger you set this number\r\n *     // the closer to ideal position graph will appear first time. But be careful: for large graphs\r\n *     // it can freeze the browser.\r\n *     prerender : 0\r\n *   }\r\n */\nfunction renderer(graph, settings) {\n  // TODO: This class is getting hard to understand. Consider refactoring.\n  // TODO: I have a technical debt here: fix scaling/recentering! Currently it's a total mess.\n  var FRAME_INTERVAL = 30;\n  settings = settings || {};\n  var layout = settings.layout,\n    graphics = settings.graphics,\n    container = settings.container,\n    interactive = settings.interactive !== undefined ? settings.interactive : true,\n    inputManager,\n    animationTimer,\n    rendererInitialized = false,\n    updateCenterRequired = true,\n    isStable = false,\n    userInteraction = false,\n    isPaused = false,\n    transform = {\n      offsetX: 0,\n      offsetY: 0,\n      scale: 1\n    },\n    publicEvents = eventify({}),\n    containerDrag;\n  return {\n    /**\r\n     * Performs rendering of the graph.\r\n     *\r\n     * @param iterationsCount if specified renderer will run only given number of iterations\r\n     * and then stop. Otherwise graph rendering is performed indefinitely.\r\n     *\r\n     * Note: if rendering stopped by used started dragging nodes or new nodes were added to the\r\n     * graph renderer will give run more iterations to reflect changes.\r\n     */\n    run: function (iterationsCount) {\n      if (!rendererInitialized) {\n        prepareSettings();\n        prerender();\n        initDom();\n        updateCenter();\n        listenToEvents();\n        rendererInitialized = true;\n      }\n      renderIterations(iterationsCount);\n      return this;\n    },\n    reset: function () {\n      graphics.resetScale();\n      updateCenter();\n      transform.scale = 1;\n    },\n    pause: function () {\n      isPaused = true;\n      animationTimer.stop();\n    },\n    resume: function () {\n      isPaused = false;\n      animationTimer.restart();\n    },\n    rerender: function () {\n      renderGraph();\n      return this;\n    },\n    zoomOut: function () {\n      return scale(true);\n    },\n    zoomIn: function () {\n      return scale(false);\n    },\n    /**\r\n     * Returns current transformation matrix.\r\n     */\n    getTransform: function () {\n      return transform;\n    },\n    /**\r\n     * Centers renderer at x,y graph's coordinates\r\n     */\n    moveTo: function (x, y) {\n      graphics.graphCenterChanged(transform.offsetX - x * transform.scale, transform.offsetY - y * transform.scale);\n      renderGraph();\n    },\n    /**\r\n     * Gets current graphics object\r\n     */\n    getGraphics: function () {\n      return graphics;\n    },\n    /**\r\n     * Gets current layout.\r\n     */\n    getLayout: function () {\n      return layout;\n    },\n    /**\r\n     * Removes this renderer and deallocates all resources/timers\r\n     */\n    dispose: function () {\n      stopListenToEvents(); // I quit!\n    },\n\n    on: function (eventName, callback) {\n      publicEvents.on(eventName, callback);\n      return this;\n    },\n    off: function (eventName, callback) {\n      publicEvents.off(eventName, callback);\n      return this;\n    }\n  };\n\n  /**\r\n   * Checks whether given interaction (node/scroll) is enabled\r\n   */\n  function isInteractive(interactionName) {\n    if (typeof interactive === 'string') {\n      return interactive.indexOf(interactionName) >= 0;\n    } else if (typeof interactive === 'boolean') {\n      return interactive;\n    }\n    return true; // default setting\n  }\n\n  function prepareSettings() {\n    container = container || window.document.body;\n    layout = layout || forceDirected(graph, {\n      springLength: 80,\n      springCoeff: 0.0002\n    });\n    graphics = graphics || svgGraphics(graph, {\n      container: container\n    });\n    if (!settings.hasOwnProperty('renderLinks')) {\n      settings.renderLinks = true;\n    }\n    settings.prerender = settings.prerender || 0;\n    inputManager = (graphics.inputManager || domInputManager)(graph, graphics);\n  }\n  function renderGraph() {\n    graphics.beginRender();\n\n    // todo: move this check graphics\n    if (settings.renderLinks) {\n      graphics.renderLinks();\n    }\n    graphics.renderNodes();\n    graphics.endRender();\n  }\n  function onRenderFrame() {\n    isStable = layout.step() && !userInteraction;\n    renderGraph();\n    return !isStable;\n  }\n  function renderIterations(iterationsCount) {\n    if (animationTimer) {\n      return;\n    }\n    if (iterationsCount !== undefined) {\n      animationTimer = timer(function () {\n        iterationsCount -= 1;\n        if (iterationsCount < 0) {\n          var needMoreFrames = false;\n          return needMoreFrames;\n        }\n        return onRenderFrame();\n      }, FRAME_INTERVAL);\n    } else {\n      animationTimer = timer(onRenderFrame, FRAME_INTERVAL);\n    }\n  }\n  function resetStable() {\n    if (isPaused) {\n      return;\n    }\n    isStable = false;\n    animationTimer.restart();\n  }\n  function prerender() {\n    // To get good initial positions for the graph\n    // perform several prerender steps in background.\n    if (typeof settings.prerender === 'number' && settings.prerender > 0) {\n      for (var i = 0; i < settings.prerender; i += 1) {\n        layout.step();\n      }\n    }\n  }\n  function updateCenter() {\n    var graphRect = layout.getGraphRect(),\n      containerSize = getDimension(container);\n    var cx = (graphRect.x2 + graphRect.x1) / 2;\n    var cy = (graphRect.y2 + graphRect.y1) / 2;\n    transform.offsetX = containerSize.width / 2 - (cx * transform.scale - cx);\n    transform.offsetY = containerSize.height / 2 - (cy * transform.scale - cy);\n    graphics.graphCenterChanged(transform.offsetX, transform.offsetY);\n    updateCenterRequired = false;\n  }\n  function createNodeUi(node) {\n    var nodePosition = layout.getNodePosition(node.id);\n    graphics.addNode(node, nodePosition);\n  }\n  function removeNodeUi(node) {\n    graphics.releaseNode(node);\n  }\n  function createLinkUi(link) {\n    var linkPosition = layout.getLinkPosition(link.id);\n    graphics.addLink(link, linkPosition);\n  }\n  function removeLinkUi(link) {\n    graphics.releaseLink(link);\n  }\n  function listenNodeEvents(node) {\n    if (!isInteractive('node')) {\n      return;\n    }\n    var wasPinned = false;\n\n    // TODO: This may not be memory efficient. Consider reusing handlers object.\n    inputManager.bindDragNDrop(node, {\n      onStart: function () {\n        wasPinned = layout.isNodePinned(node);\n        layout.pinNode(node, true);\n        userInteraction = true;\n        resetStable();\n      },\n      onDrag: function (e, offset) {\n        var oldPos = layout.getNodePosition(node.id);\n        layout.setNodePosition(node.id, oldPos.x + offset.x / transform.scale, oldPos.y + offset.y / transform.scale);\n        userInteraction = true;\n        renderGraph();\n      },\n      onStop: function () {\n        layout.pinNode(node, wasPinned);\n        userInteraction = false;\n      }\n    });\n  }\n  function releaseNodeEvents(node) {\n    inputManager.bindDragNDrop(node, null);\n  }\n  function initDom() {\n    graphics.init(container);\n    graph.forEachNode(createNodeUi);\n    if (settings.renderLinks) {\n      graph.forEachLink(createLinkUi);\n    }\n  }\n  function releaseDom() {\n    graphics.release(container);\n  }\n  function processNodeChange(change) {\n    var node = change.node;\n    if (change.changeType === 'add') {\n      createNodeUi(node);\n      listenNodeEvents(node);\n      if (updateCenterRequired) {\n        updateCenter();\n      }\n    } else if (change.changeType === 'remove') {\n      releaseNodeEvents(node);\n      removeNodeUi(node);\n      if (graph.getNodesCount() === 0) {\n        updateCenterRequired = true; // Next time when node is added - center the graph.\n      }\n    } else if (change.changeType === 'update') {\n      releaseNodeEvents(node);\n      removeNodeUi(node);\n      createNodeUi(node);\n      listenNodeEvents(node);\n    }\n  }\n  function processLinkChange(change) {\n    var link = change.link;\n    if (change.changeType === 'add') {\n      if (settings.renderLinks) {\n        createLinkUi(link);\n      }\n    } else if (change.changeType === 'remove') {\n      if (settings.renderLinks) {\n        removeLinkUi(link);\n      }\n    } else if (change.changeType === 'update') {\n      throw 'Update type is not implemented. TODO: Implement me!';\n    }\n  }\n  function onGraphChanged(changes) {\n    var i, change;\n    for (i = 0; i < changes.length; i += 1) {\n      change = changes[i];\n      if (change.node) {\n        processNodeChange(change);\n      } else if (change.link) {\n        processLinkChange(change);\n      }\n    }\n    resetStable();\n  }\n  function onWindowResized() {\n    updateCenter();\n    onRenderFrame();\n  }\n  function releaseContainerDragManager() {\n    if (containerDrag) {\n      containerDrag.release();\n      containerDrag = null;\n    }\n  }\n  function releaseGraphEvents() {\n    graph.off('changed', onGraphChanged);\n  }\n  function scale(out, scrollPoint) {\n    if (!scrollPoint) {\n      var containerSize = getDimension(container);\n      scrollPoint = {\n        x: containerSize.width / 2,\n        y: containerSize.height / 2\n      };\n    }\n    var scaleFactor = Math.pow(1 + 0.4, out ? -0.2 : 0.2);\n    transform.scale = graphics.scale(scaleFactor, scrollPoint);\n    renderGraph();\n    publicEvents.fire('scale', transform.scale);\n    return transform.scale;\n  }\n  function listenToEvents() {\n    windowEvents.on('resize', onWindowResized);\n    releaseContainerDragManager();\n    if (isInteractive('drag')) {\n      containerDrag = dragndrop(container);\n      containerDrag.onDrag(function (e, offset) {\n        graphics.translateRel(offset.x, offset.y);\n        renderGraph();\n        publicEvents.fire('drag', offset);\n      });\n    }\n    if (isInteractive('scroll')) {\n      if (!containerDrag) {\n        containerDrag = dragndrop(container);\n      }\n      containerDrag.onScroll(function (e, scaleOffset, scrollPoint) {\n        scale(scaleOffset < 0, scrollPoint);\n      });\n    }\n    graph.forEachNode(listenNodeEvents);\n    releaseGraphEvents();\n    graph.on('changed', onGraphChanged);\n  }\n  function stopListenToEvents() {\n    rendererInitialized = false;\n    releaseGraphEvents();\n    releaseContainerDragManager();\n    windowEvents.off('resize', onWindowResized);\n    publicEvents.off();\n    animationTimer.stop();\n    graph.forEachLink(function (link) {\n      if (settings.renderLinks) {\n        removeLinkUi(link);\n      }\n    });\n    graph.forEachNode(function (node) {\n      releaseNodeEvents(node);\n      removeNodeUi(node);\n    });\n    layout.dispose();\n    releaseDom();\n  }\n}","map":{"version":3,"names":["module","exports","renderer","eventify","require","forceDirected","svgGraphics","windowEvents","domInputManager","timer","getDimension","dragndrop","graph","settings","FRAME_INTERVAL","layout","graphics","container","interactive","undefined","inputManager","animationTimer","rendererInitialized","updateCenterRequired","isStable","userInteraction","isPaused","transform","offsetX","offsetY","scale","publicEvents","containerDrag","run","iterationsCount","prepareSettings","prerender","initDom","updateCenter","listenToEvents","renderIterations","reset","resetScale","pause","stop","resume","restart","rerender","renderGraph","zoomOut","zoomIn","getTransform","moveTo","x","y","graphCenterChanged","getGraphics","getLayout","dispose","stopListenToEvents","on","eventName","callback","off","isInteractive","interactionName","indexOf","window","document","body","springLength","springCoeff","hasOwnProperty","renderLinks","beginRender","renderNodes","endRender","onRenderFrame","step","needMoreFrames","resetStable","i","graphRect","getGraphRect","containerSize","cx","x2","x1","cy","y2","y1","width","height","createNodeUi","node","nodePosition","getNodePosition","id","addNode","removeNodeUi","releaseNode","createLinkUi","link","linkPosition","getLinkPosition","addLink","removeLinkUi","releaseLink","listenNodeEvents","wasPinned","bindDragNDrop","onStart","isNodePinned","pinNode","onDrag","e","offset","oldPos","setNodePosition","onStop","releaseNodeEvents","init","forEachNode","forEachLink","releaseDom","release","processNodeChange","change","changeType","getNodesCount","processLinkChange","onGraphChanged","changes","length","onWindowResized","releaseContainerDragManager","releaseGraphEvents","out","scrollPoint","scaleFactor","Math","pow","fire","translateRel","onScroll","scaleOffset"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/vivagraphjs/src/View/renderer.js"],"sourcesContent":["/**\r\n * @fileOverview Defines a graph renderer that uses CSS based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\r\n\r\nmodule.exports = renderer;\r\n\r\nvar eventify = require('ngraph.events');\r\nvar forceDirected = require('ngraph.forcelayout');\r\nvar svgGraphics = require('./svgGraphics.js');\r\nvar windowEvents = require('../Utils/windowEvents.js');\r\nvar domInputManager = require('../Input/domInputManager.js');\r\nvar timer = require('../Utils/timer.js');\r\nvar getDimension = require('../Utils/getDimensions.js');\r\nvar dragndrop = require('../Input/dragndrop.js');\r\n\r\n/**\r\n * This is heart of the rendering. Class accepts graph to be rendered and rendering settings.\r\n * It monitors graph changes and depicts them accordingly.\r\n *\r\n * @param graph - Viva.Graph.graph() object to be rendered.\r\n * @param settings - rendering settings, composed from the following parts (with their defaults shown):\r\n *   settings = {\r\n *     // Represents a module that is capable of displaying graph nodes and links.\r\n *     // all graphics has to correspond to defined interface and can be later easily\r\n *     // replaced for specific needs (e.g. adding WebGL should be piece of cake as long\r\n *     // as WebGL has implemented required interface). See svgGraphics for example.\r\n *     graphics : Viva.Graph.View.svgGraphics(),\r\n *\r\n *     // Where the renderer should draw graph. Container size matters, because\r\n *     // renderer will attempt center graph to that size. Also graphics modules\r\n *     // might depend on it.\r\n *     container : document.body,\r\n *\r\n *     // Defines whether graph can respond to use input\r\n *     interactive: true,\r\n *\r\n *     // Layout algorithm to be used. The algorithm is expected to comply with defined\r\n *     // interface and is expected to be iterative. Renderer will use it then to calculate\r\n *     // graph's layout. For examples of the interface refer to Viva.Graph.Layout.forceDirected()\r\n *     layout : Viva.Graph.Layout.forceDirected(),\r\n *\r\n *     // Directs renderer to display links. Usually rendering links is the slowest part of this\r\n *     // library. So if you don't need to display links, consider settings this property to false.\r\n *     renderLinks : true,\r\n *\r\n *     // Number of layout iterations to run before displaying the graph. The bigger you set this number\r\n *     // the closer to ideal position graph will appear first time. But be careful: for large graphs\r\n *     // it can freeze the browser.\r\n *     prerender : 0\r\n *   }\r\n */\r\nfunction renderer(graph, settings) {\r\n  // TODO: This class is getting hard to understand. Consider refactoring.\r\n  // TODO: I have a technical debt here: fix scaling/recentering! Currently it's a total mess.\r\n  var FRAME_INTERVAL = 30;\r\n\r\n  settings = settings || {};\r\n\r\n  var layout = settings.layout,\r\n    graphics = settings.graphics,\r\n    container = settings.container,\r\n    interactive = settings.interactive !== undefined ? settings.interactive : true,\r\n    inputManager,\r\n    animationTimer,\r\n    rendererInitialized = false,\r\n    updateCenterRequired = true,\r\n\r\n    isStable = false,\r\n    userInteraction = false,\r\n    isPaused = false,\r\n\r\n    transform = {\r\n      offsetX: 0,\r\n      offsetY: 0,\r\n      scale: 1\r\n    },\r\n\r\n    publicEvents = eventify({}),\r\n    containerDrag;\r\n\r\n  return {\r\n    /**\r\n     * Performs rendering of the graph.\r\n     *\r\n     * @param iterationsCount if specified renderer will run only given number of iterations\r\n     * and then stop. Otherwise graph rendering is performed indefinitely.\r\n     *\r\n     * Note: if rendering stopped by used started dragging nodes or new nodes were added to the\r\n     * graph renderer will give run more iterations to reflect changes.\r\n     */\r\n    run: function(iterationsCount) {\r\n\r\n      if (!rendererInitialized) {\r\n        prepareSettings();\r\n        prerender();\r\n\r\n        initDom();\r\n        updateCenter();\r\n        listenToEvents();\r\n\r\n        rendererInitialized = true;\r\n      }\r\n\r\n      renderIterations(iterationsCount);\r\n\r\n      return this;\r\n    },\r\n\r\n    reset: function() {\r\n      graphics.resetScale();\r\n      updateCenter();\r\n      transform.scale = 1;\r\n    },\r\n\r\n    pause: function() {\r\n      isPaused = true;\r\n      animationTimer.stop();\r\n    },\r\n\r\n    resume: function() {\r\n      isPaused = false;\r\n      animationTimer.restart();\r\n    },\r\n\r\n    rerender: function() {\r\n      renderGraph();\r\n      return this;\r\n    },\r\n\r\n    zoomOut: function() {\r\n      return scale(true);\r\n    },\r\n\r\n    zoomIn: function() {\r\n      return scale(false);\r\n    },\r\n\r\n    /**\r\n     * Returns current transformation matrix.\r\n     */\r\n    getTransform: function() {\r\n      return transform;\r\n    },\r\n\r\n    /**\r\n     * Centers renderer at x,y graph's coordinates\r\n     */\r\n    moveTo: function(x, y) {\r\n      graphics.graphCenterChanged(transform.offsetX - x * transform.scale, transform.offsetY - y * transform.scale);\r\n      renderGraph();\r\n    },\r\n\r\n    /**\r\n     * Gets current graphics object\r\n     */\r\n    getGraphics: function() {\r\n      return graphics;\r\n    },\r\n    \r\n    /**\r\n     * Gets current layout.\r\n     */\r\n    getLayout: function() {\r\n      return layout;\r\n    },\r\n\r\n    /**\r\n     * Removes this renderer and deallocates all resources/timers\r\n     */\r\n    dispose: function() {\r\n      stopListenToEvents(); // I quit!\r\n    },\r\n\r\n    on: function(eventName, callback) {\r\n      publicEvents.on(eventName, callback);\r\n      return this;\r\n    },\r\n\r\n    off: function(eventName, callback) {\r\n      publicEvents.off(eventName, callback);\r\n      return this;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Checks whether given interaction (node/scroll) is enabled\r\n   */\r\n  function isInteractive(interactionName) {\r\n    if (typeof interactive === 'string') {\r\n      return interactive.indexOf(interactionName) >= 0;\r\n    } else if (typeof interactive === 'boolean') {\r\n      return interactive;\r\n    }\r\n    return true; // default setting\r\n  }\r\n\r\n  function prepareSettings() {\r\n    container = container || window.document.body;\r\n    layout = layout || forceDirected(graph, {\r\n      springLength: 80,\r\n      springCoeff: 0.0002,\r\n    });\r\n    graphics = graphics || svgGraphics(graph, {\r\n      container: container\r\n    });\r\n\r\n    if (!settings.hasOwnProperty('renderLinks')) {\r\n      settings.renderLinks = true;\r\n    }\r\n\r\n    settings.prerender = settings.prerender || 0;\r\n    inputManager = (graphics.inputManager || domInputManager)(graph, graphics);\r\n  }\r\n\r\n  function renderGraph() {\r\n    graphics.beginRender();\r\n\r\n    // todo: move this check graphics\r\n    if (settings.renderLinks) {\r\n      graphics.renderLinks();\r\n    }\r\n    graphics.renderNodes();\r\n    graphics.endRender();\r\n  }\r\n\r\n  function onRenderFrame() {\r\n    isStable = layout.step() && !userInteraction;\r\n    renderGraph();\r\n\r\n    return !isStable;\r\n  }\r\n\r\n  function renderIterations(iterationsCount) {\r\n    if (animationTimer) {\r\n      return;\r\n    }\r\n\r\n    if (iterationsCount !== undefined) {\r\n      animationTimer = timer(function() {\r\n        iterationsCount -= 1;\r\n        if (iterationsCount < 0) {\r\n          var needMoreFrames = false;\r\n          return needMoreFrames;\r\n        }\r\n\r\n        return onRenderFrame();\r\n      }, FRAME_INTERVAL);\r\n    } else {\r\n      animationTimer = timer(onRenderFrame, FRAME_INTERVAL);\r\n    }\r\n  }\r\n\r\n  function resetStable() {\r\n    if (isPaused) {\r\n      return;\r\n    }\r\n\r\n    isStable = false;\r\n    animationTimer.restart();\r\n  }\r\n\r\n  function prerender() {\r\n    // To get good initial positions for the graph\r\n    // perform several prerender steps in background.\r\n    if (typeof settings.prerender === 'number' && settings.prerender > 0) {\r\n      for (var i = 0; i < settings.prerender; i += 1) {\r\n        layout.step();\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateCenter() {\r\n    var graphRect = layout.getGraphRect(),\r\n      containerSize = getDimension(container);\r\n\r\n    var cx = (graphRect.x2 + graphRect.x1) / 2;\r\n    var cy = (graphRect.y2 + graphRect.y1) / 2;\r\n    transform.offsetX = containerSize.width / 2 - (cx * transform.scale - cx);\r\n    transform.offsetY = containerSize.height / 2 - (cy * transform.scale - cy);\r\n    graphics.graphCenterChanged(transform.offsetX, transform.offsetY);\r\n\r\n    updateCenterRequired = false;\r\n  }\r\n\r\n  function createNodeUi(node) {\r\n    var nodePosition = layout.getNodePosition(node.id);\r\n    graphics.addNode(node, nodePosition);\r\n  }\r\n\r\n  function removeNodeUi(node) {\r\n    graphics.releaseNode(node);\r\n  }\r\n\r\n  function createLinkUi(link) {\r\n    var linkPosition = layout.getLinkPosition(link.id);\r\n    graphics.addLink(link, linkPosition);\r\n  }\r\n\r\n  function removeLinkUi(link) {\r\n    graphics.releaseLink(link);\r\n  }\r\n\r\n  function listenNodeEvents(node) {\r\n    if (!isInteractive('node')) {\r\n      return;\r\n    }\r\n\r\n    var wasPinned = false;\r\n\r\n    // TODO: This may not be memory efficient. Consider reusing handlers object.\r\n    inputManager.bindDragNDrop(node, {\r\n      onStart: function() {\r\n        wasPinned = layout.isNodePinned(node);\r\n        layout.pinNode(node, true);\r\n        userInteraction = true;\r\n        resetStable();\r\n      },\r\n      onDrag: function(e, offset) {\r\n        var oldPos = layout.getNodePosition(node.id);\r\n        layout.setNodePosition(node.id,\r\n          oldPos.x + offset.x / transform.scale,\r\n          oldPos.y + offset.y / transform.scale);\r\n\r\n        userInteraction = true;\r\n\r\n        renderGraph();\r\n      },\r\n      onStop: function() {\r\n        layout.pinNode(node, wasPinned);\r\n        userInteraction = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  function releaseNodeEvents(node) {\r\n    inputManager.bindDragNDrop(node, null);\r\n  }\r\n\r\n  function initDom() {\r\n    graphics.init(container);\r\n\r\n    graph.forEachNode(createNodeUi);\r\n\r\n    if (settings.renderLinks) {\r\n      graph.forEachLink(createLinkUi);\r\n    }\r\n  }\r\n\r\n  function releaseDom() {\r\n    graphics.release(container);\r\n  }\r\n\r\n  function processNodeChange(change) {\r\n    var node = change.node;\r\n\r\n    if (change.changeType === 'add') {\r\n      createNodeUi(node);\r\n      listenNodeEvents(node);\r\n      if (updateCenterRequired) {\r\n        updateCenter();\r\n      }\r\n    } else if (change.changeType === 'remove') {\r\n      releaseNodeEvents(node);\r\n      removeNodeUi(node);\r\n      if (graph.getNodesCount() === 0) {\r\n        updateCenterRequired = true; // Next time when node is added - center the graph.\r\n      }\r\n    } else if (change.changeType === 'update') {\r\n      releaseNodeEvents(node);\r\n      removeNodeUi(node);\r\n\r\n      createNodeUi(node);\r\n      listenNodeEvents(node);\r\n    }\r\n  }\r\n\r\n  function processLinkChange(change) {\r\n    var link = change.link;\r\n    if (change.changeType === 'add') {\r\n      if (settings.renderLinks) {\r\n        createLinkUi(link);\r\n      }\r\n    } else if (change.changeType === 'remove') {\r\n      if (settings.renderLinks) {\r\n        removeLinkUi(link);\r\n      }\r\n    } else if (change.changeType === 'update') {\r\n      throw 'Update type is not implemented. TODO: Implement me!';\r\n    }\r\n  }\r\n\r\n  function onGraphChanged(changes) {\r\n    var i, change;\r\n    for (i = 0; i < changes.length; i += 1) {\r\n      change = changes[i];\r\n      if (change.node) {\r\n        processNodeChange(change);\r\n      } else if (change.link) {\r\n        processLinkChange(change);\r\n      }\r\n    }\r\n\r\n    resetStable();\r\n  }\r\n\r\n  function onWindowResized() {\r\n    updateCenter();\r\n    onRenderFrame();\r\n  }\r\n\r\n  function releaseContainerDragManager() {\r\n    if (containerDrag) {\r\n      containerDrag.release();\r\n      containerDrag = null;\r\n    }\r\n  }\r\n\r\n  function releaseGraphEvents() {\r\n    graph.off('changed', onGraphChanged);\r\n  }\r\n\r\n  function scale(out, scrollPoint) {\r\n    if (!scrollPoint) {\r\n      var containerSize = getDimension(container);\r\n      scrollPoint = {\r\n        x: containerSize.width / 2,\r\n        y: containerSize.height / 2\r\n      };\r\n    }\r\n    var scaleFactor = Math.pow(1 + 0.4, out ? -0.2 : 0.2);\r\n    transform.scale = graphics.scale(scaleFactor, scrollPoint);\r\n\r\n    renderGraph();\r\n    publicEvents.fire('scale', transform.scale);\r\n\r\n    return transform.scale;\r\n  }\r\n\r\n  function listenToEvents() {\r\n    windowEvents.on('resize', onWindowResized);\r\n\r\n    releaseContainerDragManager();\r\n    if (isInteractive('drag')) {\r\n      containerDrag = dragndrop(container);\r\n      containerDrag.onDrag(function(e, offset) {\r\n        graphics.translateRel(offset.x, offset.y);\r\n\r\n        renderGraph();\r\n        publicEvents.fire('drag', offset);\r\n      });\r\n    }\r\n\r\n    if (isInteractive('scroll')) {\r\n      if (!containerDrag) {\r\n        containerDrag = dragndrop(container);\r\n      }\r\n      containerDrag.onScroll(function(e, scaleOffset, scrollPoint) {\r\n        scale(scaleOffset < 0, scrollPoint);\r\n      });\r\n    }\r\n\r\n    graph.forEachNode(listenNodeEvents);\r\n\r\n    releaseGraphEvents();\r\n    graph.on('changed', onGraphChanged);\r\n  }\r\n\r\n  function stopListenToEvents() {\r\n    rendererInitialized = false;\r\n    releaseGraphEvents();\r\n    releaseContainerDragManager();\r\n    windowEvents.off('resize', onWindowResized);\r\n    publicEvents.off();\r\n    animationTimer.stop();\r\n\r\n    graph.forEachLink(function(link) {\r\n      if (settings.renderLinks) {\r\n        removeLinkUi(link);\r\n      }\r\n    });\r\n\r\n    graph.forEachNode(function(node) {\r\n      releaseNodeEvents(node);\r\n      removeNodeUi(node);\r\n    });\r\n\r\n    layout.dispose();\r\n    releaseDom();\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAO,GAAGC,QAAQ;AAEzB,IAAIC,QAAQ,GAAGC,OAAO,CAAC,eAAe,CAAC;AACvC,IAAIC,aAAa,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AACjD,IAAIE,WAAW,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AAC7C,IAAIG,YAAY,GAAGH,OAAO,CAAC,0BAA0B,CAAC;AACtD,IAAII,eAAe,GAAGJ,OAAO,CAAC,6BAA6B,CAAC;AAC5D,IAAIK,KAAK,GAAGL,OAAO,CAAC,mBAAmB,CAAC;AACxC,IAAIM,YAAY,GAAGN,OAAO,CAAC,2BAA2B,CAAC;AACvD,IAAIO,SAAS,GAAGP,OAAO,CAAC,uBAAuB,CAAC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,QAAQA,CAACU,KAAK,EAAEC,QAAQ,EAAE;EACjC;EACA;EACA,IAAIC,cAAc,GAAG,EAAE;EAEvBD,QAAQ,GAAGA,QAAQ,IAAI,CAAC,CAAC;EAEzB,IAAIE,MAAM,GAAGF,QAAQ,CAACE,MAAM;IAC1BC,QAAQ,GAAGH,QAAQ,CAACG,QAAQ;IAC5BC,SAAS,GAAGJ,QAAQ,CAACI,SAAS;IAC9BC,WAAW,GAAGL,QAAQ,CAACK,WAAW,KAAKC,SAAS,GAAGN,QAAQ,CAACK,WAAW,GAAG,IAAI;IAC9EE,YAAY;IACZC,cAAc;IACdC,mBAAmB,GAAG,KAAK;IAC3BC,oBAAoB,GAAG,IAAI;IAE3BC,QAAQ,GAAG,KAAK;IAChBC,eAAe,GAAG,KAAK;IACvBC,QAAQ,GAAG,KAAK;IAEhBC,SAAS,GAAG;MACVC,OAAO,EAAE,CAAC;MACVC,OAAO,EAAE,CAAC;MACVC,KAAK,EAAE;IACT,CAAC;IAEDC,YAAY,GAAG5B,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC3B6B,aAAa;EAEf,OAAO;IACL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,GAAG,EAAE,SAAAA,CAASC,eAAe,EAAE;MAE7B,IAAI,CAACZ,mBAAmB,EAAE;QACxBa,eAAe,EAAE;QACjBC,SAAS,EAAE;QAEXC,OAAO,EAAE;QACTC,YAAY,EAAE;QACdC,cAAc,EAAE;QAEhBjB,mBAAmB,GAAG,IAAI;MAC5B;MAEAkB,gBAAgB,CAACN,eAAe,CAAC;MAEjC,OAAO,IAAI;IACb,CAAC;IAEDO,KAAK,EAAE,SAAAA,CAAA,EAAW;MAChBzB,QAAQ,CAAC0B,UAAU,EAAE;MACrBJ,YAAY,EAAE;MACdX,SAAS,CAACG,KAAK,GAAG,CAAC;IACrB,CAAC;IAEDa,KAAK,EAAE,SAAAA,CAAA,EAAW;MAChBjB,QAAQ,GAAG,IAAI;MACfL,cAAc,CAACuB,IAAI,EAAE;IACvB,CAAC;IAEDC,MAAM,EAAE,SAAAA,CAAA,EAAW;MACjBnB,QAAQ,GAAG,KAAK;MAChBL,cAAc,CAACyB,OAAO,EAAE;IAC1B,CAAC;IAEDC,QAAQ,EAAE,SAAAA,CAAA,EAAW;MACnBC,WAAW,EAAE;MACb,OAAO,IAAI;IACb,CAAC;IAEDC,OAAO,EAAE,SAAAA,CAAA,EAAW;MAClB,OAAOnB,KAAK,CAAC,IAAI,CAAC;IACpB,CAAC;IAEDoB,MAAM,EAAE,SAAAA,CAAA,EAAW;MACjB,OAAOpB,KAAK,CAAC,KAAK,CAAC;IACrB,CAAC;IAED;AACJ;AACA;IACIqB,YAAY,EAAE,SAAAA,CAAA,EAAW;MACvB,OAAOxB,SAAS;IAClB,CAAC;IAED;AACJ;AACA;IACIyB,MAAM,EAAE,SAAAA,CAASC,CAAC,EAAEC,CAAC,EAAE;MACrBtC,QAAQ,CAACuC,kBAAkB,CAAC5B,SAAS,CAACC,OAAO,GAAGyB,CAAC,GAAG1B,SAAS,CAACG,KAAK,EAAEH,SAAS,CAACE,OAAO,GAAGyB,CAAC,GAAG3B,SAAS,CAACG,KAAK,CAAC;MAC7GkB,WAAW,EAAE;IACf,CAAC;IAED;AACJ;AACA;IACIQ,WAAW,EAAE,SAAAA,CAAA,EAAW;MACtB,OAAOxC,QAAQ;IACjB,CAAC;IAED;AACJ;AACA;IACIyC,SAAS,EAAE,SAAAA,CAAA,EAAW;MACpB,OAAO1C,MAAM;IACf,CAAC;IAED;AACJ;AACA;IACI2C,OAAO,EAAE,SAAAA,CAAA,EAAW;MAClBC,kBAAkB,EAAE,CAAC,CAAC;IACxB,CAAC;;IAEDC,EAAE,EAAE,SAAAA,CAASC,SAAS,EAAEC,QAAQ,EAAE;MAChC/B,YAAY,CAAC6B,EAAE,CAACC,SAAS,EAAEC,QAAQ,CAAC;MACpC,OAAO,IAAI;IACb,CAAC;IAEDC,GAAG,EAAE,SAAAA,CAASF,SAAS,EAAEC,QAAQ,EAAE;MACjC/B,YAAY,CAACgC,GAAG,CAACF,SAAS,EAAEC,QAAQ,CAAC;MACrC,OAAO,IAAI;IACb;EACF,CAAC;;EAED;AACF;AACA;EACE,SAASE,aAAaA,CAACC,eAAe,EAAE;IACtC,IAAI,OAAO/C,WAAW,KAAK,QAAQ,EAAE;MACnC,OAAOA,WAAW,CAACgD,OAAO,CAACD,eAAe,CAAC,IAAI,CAAC;IAClD,CAAC,MAAM,IAAI,OAAO/C,WAAW,KAAK,SAAS,EAAE;MAC3C,OAAOA,WAAW;IACpB;IACA,OAAO,IAAI,CAAC,CAAC;EACf;;EAEA,SAASiB,eAAeA,CAAA,EAAG;IACzBlB,SAAS,GAAGA,SAAS,IAAIkD,MAAM,CAACC,QAAQ,CAACC,IAAI;IAC7CtD,MAAM,GAAGA,MAAM,IAAIV,aAAa,CAACO,KAAK,EAAE;MACtC0D,YAAY,EAAE,EAAE;MAChBC,WAAW,EAAE;IACf,CAAC,CAAC;IACFvD,QAAQ,GAAGA,QAAQ,IAAIV,WAAW,CAACM,KAAK,EAAE;MACxCK,SAAS,EAAEA;IACb,CAAC,CAAC;IAEF,IAAI,CAACJ,QAAQ,CAAC2D,cAAc,CAAC,aAAa,CAAC,EAAE;MAC3C3D,QAAQ,CAAC4D,WAAW,GAAG,IAAI;IAC7B;IAEA5D,QAAQ,CAACuB,SAAS,GAAGvB,QAAQ,CAACuB,SAAS,IAAI,CAAC;IAC5ChB,YAAY,GAAG,CAACJ,QAAQ,CAACI,YAAY,IAAIZ,eAAe,EAAEI,KAAK,EAAEI,QAAQ,CAAC;EAC5E;EAEA,SAASgC,WAAWA,CAAA,EAAG;IACrBhC,QAAQ,CAAC0D,WAAW,EAAE;;IAEtB;IACA,IAAI7D,QAAQ,CAAC4D,WAAW,EAAE;MACxBzD,QAAQ,CAACyD,WAAW,EAAE;IACxB;IACAzD,QAAQ,CAAC2D,WAAW,EAAE;IACtB3D,QAAQ,CAAC4D,SAAS,EAAE;EACtB;EAEA,SAASC,aAAaA,CAAA,EAAG;IACvBrD,QAAQ,GAAGT,MAAM,CAAC+D,IAAI,EAAE,IAAI,CAACrD,eAAe;IAC5CuB,WAAW,EAAE;IAEb,OAAO,CAACxB,QAAQ;EAClB;EAEA,SAASgB,gBAAgBA,CAACN,eAAe,EAAE;IACzC,IAAIb,cAAc,EAAE;MAClB;IACF;IAEA,IAAIa,eAAe,KAAKf,SAAS,EAAE;MACjCE,cAAc,GAAGZ,KAAK,CAAC,YAAW;QAChCyB,eAAe,IAAI,CAAC;QACpB,IAAIA,eAAe,GAAG,CAAC,EAAE;UACvB,IAAI6C,cAAc,GAAG,KAAK;UAC1B,OAAOA,cAAc;QACvB;QAEA,OAAOF,aAAa,EAAE;MACxB,CAAC,EAAE/D,cAAc,CAAC;IACpB,CAAC,MAAM;MACLO,cAAc,GAAGZ,KAAK,CAACoE,aAAa,EAAE/D,cAAc,CAAC;IACvD;EACF;EAEA,SAASkE,WAAWA,CAAA,EAAG;IACrB,IAAItD,QAAQ,EAAE;MACZ;IACF;IAEAF,QAAQ,GAAG,KAAK;IAChBH,cAAc,CAACyB,OAAO,EAAE;EAC1B;EAEA,SAASV,SAASA,CAAA,EAAG;IACnB;IACA;IACA,IAAI,OAAOvB,QAAQ,CAACuB,SAAS,KAAK,QAAQ,IAAIvB,QAAQ,CAACuB,SAAS,GAAG,CAAC,EAAE;MACpE,KAAK,IAAI6C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpE,QAAQ,CAACuB,SAAS,EAAE6C,CAAC,IAAI,CAAC,EAAE;QAC9ClE,MAAM,CAAC+D,IAAI,EAAE;MACf;IACF;EACF;EAEA,SAASxC,YAAYA,CAAA,EAAG;IACtB,IAAI4C,SAAS,GAAGnE,MAAM,CAACoE,YAAY,EAAE;MACnCC,aAAa,GAAG1E,YAAY,CAACO,SAAS,CAAC;IAEzC,IAAIoE,EAAE,GAAG,CAACH,SAAS,CAACI,EAAE,GAAGJ,SAAS,CAACK,EAAE,IAAI,CAAC;IAC1C,IAAIC,EAAE,GAAG,CAACN,SAAS,CAACO,EAAE,GAAGP,SAAS,CAACQ,EAAE,IAAI,CAAC;IAC1C/D,SAAS,CAACC,OAAO,GAAGwD,aAAa,CAACO,KAAK,GAAG,CAAC,IAAIN,EAAE,GAAG1D,SAAS,CAACG,KAAK,GAAGuD,EAAE,CAAC;IACzE1D,SAAS,CAACE,OAAO,GAAGuD,aAAa,CAACQ,MAAM,GAAG,CAAC,IAAIJ,EAAE,GAAG7D,SAAS,CAACG,KAAK,GAAG0D,EAAE,CAAC;IAC1ExE,QAAQ,CAACuC,kBAAkB,CAAC5B,SAAS,CAACC,OAAO,EAAED,SAAS,CAACE,OAAO,CAAC;IAEjEN,oBAAoB,GAAG,KAAK;EAC9B;EAEA,SAASsE,YAAYA,CAACC,IAAI,EAAE;IAC1B,IAAIC,YAAY,GAAGhF,MAAM,CAACiF,eAAe,CAACF,IAAI,CAACG,EAAE,CAAC;IAClDjF,QAAQ,CAACkF,OAAO,CAACJ,IAAI,EAAEC,YAAY,CAAC;EACtC;EAEA,SAASI,YAAYA,CAACL,IAAI,EAAE;IAC1B9E,QAAQ,CAACoF,WAAW,CAACN,IAAI,CAAC;EAC5B;EAEA,SAASO,YAAYA,CAACC,IAAI,EAAE;IAC1B,IAAIC,YAAY,GAAGxF,MAAM,CAACyF,eAAe,CAACF,IAAI,CAACL,EAAE,CAAC;IAClDjF,QAAQ,CAACyF,OAAO,CAACH,IAAI,EAAEC,YAAY,CAAC;EACtC;EAEA,SAASG,YAAYA,CAACJ,IAAI,EAAE;IAC1BtF,QAAQ,CAAC2F,WAAW,CAACL,IAAI,CAAC;EAC5B;EAEA,SAASM,gBAAgBA,CAACd,IAAI,EAAE;IAC9B,IAAI,CAAC9B,aAAa,CAAC,MAAM,CAAC,EAAE;MAC1B;IACF;IAEA,IAAI6C,SAAS,GAAG,KAAK;;IAErB;IACAzF,YAAY,CAAC0F,aAAa,CAAChB,IAAI,EAAE;MAC/BiB,OAAO,EAAE,SAAAA,CAAA,EAAW;QAClBF,SAAS,GAAG9F,MAAM,CAACiG,YAAY,CAAClB,IAAI,CAAC;QACrC/E,MAAM,CAACkG,OAAO,CAACnB,IAAI,EAAE,IAAI,CAAC;QAC1BrE,eAAe,GAAG,IAAI;QACtBuD,WAAW,EAAE;MACf,CAAC;MACDkC,MAAM,EAAE,SAAAA,CAASC,CAAC,EAAEC,MAAM,EAAE;QAC1B,IAAIC,MAAM,GAAGtG,MAAM,CAACiF,eAAe,CAACF,IAAI,CAACG,EAAE,CAAC;QAC5ClF,MAAM,CAACuG,eAAe,CAACxB,IAAI,CAACG,EAAE,EAC5BoB,MAAM,CAAChE,CAAC,GAAG+D,MAAM,CAAC/D,CAAC,GAAG1B,SAAS,CAACG,KAAK,EACrCuF,MAAM,CAAC/D,CAAC,GAAG8D,MAAM,CAAC9D,CAAC,GAAG3B,SAAS,CAACG,KAAK,CAAC;QAExCL,eAAe,GAAG,IAAI;QAEtBuB,WAAW,EAAE;MACf,CAAC;MACDuE,MAAM,EAAE,SAAAA,CAAA,EAAW;QACjBxG,MAAM,CAACkG,OAAO,CAACnB,IAAI,EAAEe,SAAS,CAAC;QAC/BpF,eAAe,GAAG,KAAK;MACzB;IACF,CAAC,CAAC;EACJ;EAEA,SAAS+F,iBAAiBA,CAAC1B,IAAI,EAAE;IAC/B1E,YAAY,CAAC0F,aAAa,CAAChB,IAAI,EAAE,IAAI,CAAC;EACxC;EAEA,SAASzD,OAAOA,CAAA,EAAG;IACjBrB,QAAQ,CAACyG,IAAI,CAACxG,SAAS,CAAC;IAExBL,KAAK,CAAC8G,WAAW,CAAC7B,YAAY,CAAC;IAE/B,IAAIhF,QAAQ,CAAC4D,WAAW,EAAE;MACxB7D,KAAK,CAAC+G,WAAW,CAACtB,YAAY,CAAC;IACjC;EACF;EAEA,SAASuB,UAAUA,CAAA,EAAG;IACpB5G,QAAQ,CAAC6G,OAAO,CAAC5G,SAAS,CAAC;EAC7B;EAEA,SAAS6G,iBAAiBA,CAACC,MAAM,EAAE;IACjC,IAAIjC,IAAI,GAAGiC,MAAM,CAACjC,IAAI;IAEtB,IAAIiC,MAAM,CAACC,UAAU,KAAK,KAAK,EAAE;MAC/BnC,YAAY,CAACC,IAAI,CAAC;MAClBc,gBAAgB,CAACd,IAAI,CAAC;MACtB,IAAIvE,oBAAoB,EAAE;QACxBe,YAAY,EAAE;MAChB;IACF,CAAC,MAAM,IAAIyF,MAAM,CAACC,UAAU,KAAK,QAAQ,EAAE;MACzCR,iBAAiB,CAAC1B,IAAI,CAAC;MACvBK,YAAY,CAACL,IAAI,CAAC;MAClB,IAAIlF,KAAK,CAACqH,aAAa,EAAE,KAAK,CAAC,EAAE;QAC/B1G,oBAAoB,GAAG,IAAI,CAAC,CAAC;MAC/B;IACF,CAAC,MAAM,IAAIwG,MAAM,CAACC,UAAU,KAAK,QAAQ,EAAE;MACzCR,iBAAiB,CAAC1B,IAAI,CAAC;MACvBK,YAAY,CAACL,IAAI,CAAC;MAElBD,YAAY,CAACC,IAAI,CAAC;MAClBc,gBAAgB,CAACd,IAAI,CAAC;IACxB;EACF;EAEA,SAASoC,iBAAiBA,CAACH,MAAM,EAAE;IACjC,IAAIzB,IAAI,GAAGyB,MAAM,CAACzB,IAAI;IACtB,IAAIyB,MAAM,CAACC,UAAU,KAAK,KAAK,EAAE;MAC/B,IAAInH,QAAQ,CAAC4D,WAAW,EAAE;QACxB4B,YAAY,CAACC,IAAI,CAAC;MACpB;IACF,CAAC,MAAM,IAAIyB,MAAM,CAACC,UAAU,KAAK,QAAQ,EAAE;MACzC,IAAInH,QAAQ,CAAC4D,WAAW,EAAE;QACxBiC,YAAY,CAACJ,IAAI,CAAC;MACpB;IACF,CAAC,MAAM,IAAIyB,MAAM,CAACC,UAAU,KAAK,QAAQ,EAAE;MACzC,MAAM,qDAAqD;IAC7D;EACF;EAEA,SAASG,cAAcA,CAACC,OAAO,EAAE;IAC/B,IAAInD,CAAC,EAAE8C,MAAM;IACb,KAAK9C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmD,OAAO,CAACC,MAAM,EAAEpD,CAAC,IAAI,CAAC,EAAE;MACtC8C,MAAM,GAAGK,OAAO,CAACnD,CAAC,CAAC;MACnB,IAAI8C,MAAM,CAACjC,IAAI,EAAE;QACfgC,iBAAiB,CAACC,MAAM,CAAC;MAC3B,CAAC,MAAM,IAAIA,MAAM,CAACzB,IAAI,EAAE;QACtB4B,iBAAiB,CAACH,MAAM,CAAC;MAC3B;IACF;IAEA/C,WAAW,EAAE;EACf;EAEA,SAASsD,eAAeA,CAAA,EAAG;IACzBhG,YAAY,EAAE;IACduC,aAAa,EAAE;EACjB;EAEA,SAAS0D,2BAA2BA,CAAA,EAAG;IACrC,IAAIvG,aAAa,EAAE;MACjBA,aAAa,CAAC6F,OAAO,EAAE;MACvB7F,aAAa,GAAG,IAAI;IACtB;EACF;EAEA,SAASwG,kBAAkBA,CAAA,EAAG;IAC5B5H,KAAK,CAACmD,GAAG,CAAC,SAAS,EAAEoE,cAAc,CAAC;EACtC;EAEA,SAASrG,KAAKA,CAAC2G,GAAG,EAAEC,WAAW,EAAE;IAC/B,IAAI,CAACA,WAAW,EAAE;MAChB,IAAItD,aAAa,GAAG1E,YAAY,CAACO,SAAS,CAAC;MAC3CyH,WAAW,GAAG;QACZrF,CAAC,EAAE+B,aAAa,CAACO,KAAK,GAAG,CAAC;QAC1BrC,CAAC,EAAE8B,aAAa,CAACQ,MAAM,GAAG;MAC5B,CAAC;IACH;IACA,IAAI+C,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,GAAG,EAAEJ,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC;IACrD9G,SAAS,CAACG,KAAK,GAAGd,QAAQ,CAACc,KAAK,CAAC6G,WAAW,EAAED,WAAW,CAAC;IAE1D1F,WAAW,EAAE;IACbjB,YAAY,CAAC+G,IAAI,CAAC,OAAO,EAAEnH,SAAS,CAACG,KAAK,CAAC;IAE3C,OAAOH,SAAS,CAACG,KAAK;EACxB;EAEA,SAASS,cAAcA,CAAA,EAAG;IACxBhC,YAAY,CAACqD,EAAE,CAAC,QAAQ,EAAE0E,eAAe,CAAC;IAE1CC,2BAA2B,EAAE;IAC7B,IAAIvE,aAAa,CAAC,MAAM,CAAC,EAAE;MACzBhC,aAAa,GAAGrB,SAAS,CAACM,SAAS,CAAC;MACpCe,aAAa,CAACkF,MAAM,CAAC,UAASC,CAAC,EAAEC,MAAM,EAAE;QACvCpG,QAAQ,CAAC+H,YAAY,CAAC3B,MAAM,CAAC/D,CAAC,EAAE+D,MAAM,CAAC9D,CAAC,CAAC;QAEzCN,WAAW,EAAE;QACbjB,YAAY,CAAC+G,IAAI,CAAC,MAAM,EAAE1B,MAAM,CAAC;MACnC,CAAC,CAAC;IACJ;IAEA,IAAIpD,aAAa,CAAC,QAAQ,CAAC,EAAE;MAC3B,IAAI,CAAChC,aAAa,EAAE;QAClBA,aAAa,GAAGrB,SAAS,CAACM,SAAS,CAAC;MACtC;MACAe,aAAa,CAACgH,QAAQ,CAAC,UAAS7B,CAAC,EAAE8B,WAAW,EAAEP,WAAW,EAAE;QAC3D5G,KAAK,CAACmH,WAAW,GAAG,CAAC,EAAEP,WAAW,CAAC;MACrC,CAAC,CAAC;IACJ;IAEA9H,KAAK,CAAC8G,WAAW,CAACd,gBAAgB,CAAC;IAEnC4B,kBAAkB,EAAE;IACpB5H,KAAK,CAACgD,EAAE,CAAC,SAAS,EAAEuE,cAAc,CAAC;EACrC;EAEA,SAASxE,kBAAkBA,CAAA,EAAG;IAC5BrC,mBAAmB,GAAG,KAAK;IAC3BkH,kBAAkB,EAAE;IACpBD,2BAA2B,EAAE;IAC7BhI,YAAY,CAACwD,GAAG,CAAC,QAAQ,EAAEuE,eAAe,CAAC;IAC3CvG,YAAY,CAACgC,GAAG,EAAE;IAClB1C,cAAc,CAACuB,IAAI,EAAE;IAErBhC,KAAK,CAAC+G,WAAW,CAAC,UAASrB,IAAI,EAAE;MAC/B,IAAIzF,QAAQ,CAAC4D,WAAW,EAAE;QACxBiC,YAAY,CAACJ,IAAI,CAAC;MACpB;IACF,CAAC,CAAC;IAEF1F,KAAK,CAAC8G,WAAW,CAAC,UAAS5B,IAAI,EAAE;MAC/B0B,iBAAiB,CAAC1B,IAAI,CAAC;MACvBK,YAAY,CAACL,IAAI,CAAC;IACpB,CAAC,CAAC;IAEF/E,MAAM,CAAC2C,OAAO,EAAE;IAChBkE,UAAU,EAAE;EACd;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}