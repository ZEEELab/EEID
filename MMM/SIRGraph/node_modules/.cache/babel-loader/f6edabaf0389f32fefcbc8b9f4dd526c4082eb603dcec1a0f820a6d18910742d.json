{"ast":null,"code":"/**\n * @fileOverview Utility functions for webgl rendering.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nmodule.exports = webgl;\nfunction webgl(gl) {\n  return {\n    createProgram: createProgram,\n    extendArray: extendArray,\n    copyArrayPart: copyArrayPart,\n    swapArrayPart: swapArrayPart,\n    getLocations: getLocations,\n    context: gl\n  };\n  function createShader(shaderText, type) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, shaderText);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      var msg = gl.getShaderInfoLog(shader);\n      window.alert(msg);\n      throw msg;\n    }\n    return shader;\n  }\n  function createProgram(vertexShaderSrc, fragmentShaderSrc) {\n    var program = gl.createProgram();\n    var vs = createShader(vertexShaderSrc, gl.VERTEX_SHADER);\n    var fs = createShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      var msg = gl.getShaderInfoLog(program);\n      window.alert(msg);\n      throw msg;\n    }\n    return program;\n  }\n  function extendArray(buffer, itemsInBuffer, elementsPerItem) {\n    if ((itemsInBuffer + 1) * elementsPerItem > buffer.length) {\n      // Every time we run out of space create new array twice bigger.\n      // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n      var extendedArray = new Float32Array(buffer.length * elementsPerItem * 2);\n      extendedArray.set(buffer);\n      return extendedArray;\n    }\n    return buffer;\n  }\n  function getLocations(program, uniformOrAttributeNames) {\n    var foundLocations = {};\n    for (var i = 0; i < uniformOrAttributeNames.length; ++i) {\n      var name = uniformOrAttributeNames[i];\n      var location = -1;\n      if (name[0] === 'a' && name[1] === '_') {\n        location = gl.getAttribLocation(program, name);\n        if (location === -1) {\n          throw new Error(\"Program doesn't have required attribute: \" + name);\n        }\n        foundLocations[name.slice(2)] = location;\n      } else if (name[0] === 'u' && name[1] === '_') {\n        location = gl.getUniformLocation(program, name);\n        if (location === null) {\n          throw new Error(\"Program doesn't have required uniform: \" + name);\n        }\n        foundLocations[name.slice(2)] = location;\n      } else {\n        throw new Error(\"Couldn't figure out your intent. All uniforms should start with 'u_' prefix, and attributes with 'a_'\");\n      }\n    }\n    return foundLocations;\n  }\n}\nfunction copyArrayPart(array, to, from, elementsCount) {\n  for (var i = 0; i < elementsCount; ++i) {\n    array[to + i] = array[from + i];\n  }\n}\nfunction swapArrayPart(array, from, to, elementsCount) {\n  for (var i = 0; i < elementsCount; ++i) {\n    var tmp = array[from + i];\n    array[from + i] = array[to + i];\n    array[to + i] = tmp;\n  }\n}","map":{"version":3,"names":["module","exports","webgl","gl","createProgram","extendArray","copyArrayPart","swapArrayPart","getLocations","context","createShader","shaderText","type","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","msg","getShaderInfoLog","window","alert","vertexShaderSrc","fragmentShaderSrc","program","vs","VERTEX_SHADER","fs","FRAGMENT_SHADER","attachShader","linkProgram","getProgramParameter","LINK_STATUS","buffer","itemsInBuffer","elementsPerItem","length","extendedArray","Float32Array","set","uniformOrAttributeNames","foundLocations","i","name","location","getAttribLocation","Error","slice","getUniformLocation","array","to","from","elementsCount","tmp"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/vivagraphjs/src/WebGL/webgl.js"],"sourcesContent":["/**\n * @fileOverview Utility functions for webgl rendering.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nmodule.exports = webgl;\n\nfunction webgl(gl) {\n\n  return {\n    createProgram: createProgram,\n    extendArray: extendArray,\n    copyArrayPart: copyArrayPart,\n    swapArrayPart: swapArrayPart,\n    getLocations: getLocations,\n    context: gl\n  };\n\n  function createShader(shaderText, type) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, shaderText);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      var msg = gl.getShaderInfoLog(shader);\n      window.alert(msg);\n      throw msg;\n    }\n\n    return shader;\n  }\n\n  function createProgram(vertexShaderSrc, fragmentShaderSrc) {\n    var program = gl.createProgram();\n    var vs = createShader(vertexShaderSrc, gl.VERTEX_SHADER);\n    var fs = createShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);\n\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      var msg = gl.getShaderInfoLog(program);\n      window.alert(msg);\n      throw msg;\n    }\n\n    return program;\n  }\n\n  function extendArray(buffer, itemsInBuffer, elementsPerItem) {\n    if ((itemsInBuffer + 1) * elementsPerItem > buffer.length) {\n      // Every time we run out of space create new array twice bigger.\n      // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n      var extendedArray = new Float32Array(buffer.length * elementsPerItem * 2);\n      extendedArray.set(buffer);\n\n      return extendedArray;\n    }\n\n    return buffer;\n  }\n\n  function getLocations(program, uniformOrAttributeNames) {\n    var foundLocations = {};\n    for (var i = 0; i < uniformOrAttributeNames.length; ++i) {\n      var name = uniformOrAttributeNames[i];\n      var location = -1;\n      if (name[0] === 'a' && name[1] === '_') {\n        location = gl.getAttribLocation(program, name);\n        if (location === -1) {\n          throw new Error(\"Program doesn't have required attribute: \" + name);\n        }\n\n        foundLocations[name.slice(2)] = location;\n      } else if (name[0] === 'u' && name[1] === '_') {\n        location = gl.getUniformLocation(program, name);\n        if (location === null) {\n          throw new Error(\"Program doesn't have required uniform: \" + name);\n        }\n\n        foundLocations[name.slice(2)] = location;\n      } else {\n        throw new Error(\"Couldn't figure out your intent. All uniforms should start with 'u_' prefix, and attributes with 'a_'\");\n      }\n    }\n\n    return foundLocations;\n  }\n}\n\nfunction copyArrayPart(array, to, from, elementsCount) {\n  for (var i = 0; i < elementsCount; ++i) {\n    array[to + i] = array[from + i];\n  }\n}\n\nfunction swapArrayPart(array, from, to, elementsCount) {\n  for (var i = 0; i < elementsCount; ++i) {\n    var tmp = array[from + i];\n    array[from + i] = array[to + i];\n    array[to + i] = tmp;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAO,GAAGC,KAAK;AAEtB,SAASA,KAAKA,CAACC,EAAE,EAAE;EAEjB,OAAO;IACLC,aAAa,EAAEA,aAAa;IAC5BC,WAAW,EAAEA,WAAW;IACxBC,aAAa,EAAEA,aAAa;IAC5BC,aAAa,EAAEA,aAAa;IAC5BC,YAAY,EAAEA,YAAY;IAC1BC,OAAO,EAAEN;EACX,CAAC;EAED,SAASO,YAAYA,CAACC,UAAU,EAAEC,IAAI,EAAE;IACtC,IAAIC,MAAM,GAAGV,EAAE,CAACO,YAAY,CAACE,IAAI,CAAC;IAClCT,EAAE,CAACW,YAAY,CAACD,MAAM,EAAEF,UAAU,CAAC;IACnCR,EAAE,CAACY,aAAa,CAACF,MAAM,CAAC;IAExB,IAAI,CAACV,EAAE,CAACa,kBAAkB,CAACH,MAAM,EAAEV,EAAE,CAACc,cAAc,CAAC,EAAE;MACrD,IAAIC,GAAG,GAAGf,EAAE,CAACgB,gBAAgB,CAACN,MAAM,CAAC;MACrCO,MAAM,CAACC,KAAK,CAACH,GAAG,CAAC;MACjB,MAAMA,GAAG;IACX;IAEA,OAAOL,MAAM;EACf;EAEA,SAAST,aAAaA,CAACkB,eAAe,EAAEC,iBAAiB,EAAE;IACzD,IAAIC,OAAO,GAAGrB,EAAE,CAACC,aAAa,EAAE;IAChC,IAAIqB,EAAE,GAAGf,YAAY,CAACY,eAAe,EAAEnB,EAAE,CAACuB,aAAa,CAAC;IACxD,IAAIC,EAAE,GAAGjB,YAAY,CAACa,iBAAiB,EAAEpB,EAAE,CAACyB,eAAe,CAAC;IAE5DzB,EAAE,CAAC0B,YAAY,CAACL,OAAO,EAAEC,EAAE,CAAC;IAC5BtB,EAAE,CAAC0B,YAAY,CAACL,OAAO,EAAEG,EAAE,CAAC;IAC5BxB,EAAE,CAAC2B,WAAW,CAACN,OAAO,CAAC;IAEvB,IAAI,CAACrB,EAAE,CAAC4B,mBAAmB,CAACP,OAAO,EAAErB,EAAE,CAAC6B,WAAW,CAAC,EAAE;MACpD,IAAId,GAAG,GAAGf,EAAE,CAACgB,gBAAgB,CAACK,OAAO,CAAC;MACtCJ,MAAM,CAACC,KAAK,CAACH,GAAG,CAAC;MACjB,MAAMA,GAAG;IACX;IAEA,OAAOM,OAAO;EAChB;EAEA,SAASnB,WAAWA,CAAC4B,MAAM,EAAEC,aAAa,EAAEC,eAAe,EAAE;IAC3D,IAAI,CAACD,aAAa,GAAG,CAAC,IAAIC,eAAe,GAAGF,MAAM,CAACG,MAAM,EAAE;MACzD;MACA;MACA,IAAIC,aAAa,GAAG,IAAIC,YAAY,CAACL,MAAM,CAACG,MAAM,GAAGD,eAAe,GAAG,CAAC,CAAC;MACzEE,aAAa,CAACE,GAAG,CAACN,MAAM,CAAC;MAEzB,OAAOI,aAAa;IACtB;IAEA,OAAOJ,MAAM;EACf;EAEA,SAASzB,YAAYA,CAACgB,OAAO,EAAEgB,uBAAuB,EAAE;IACtD,IAAIC,cAAc,GAAG,CAAC,CAAC;IACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,uBAAuB,CAACJ,MAAM,EAAE,EAAEM,CAAC,EAAE;MACvD,IAAIC,IAAI,GAAGH,uBAAuB,CAACE,CAAC,CAAC;MACrC,IAAIE,QAAQ,GAAG,CAAC,CAAC;MACjB,IAAID,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACtCC,QAAQ,GAAGzC,EAAE,CAAC0C,iBAAiB,CAACrB,OAAO,EAAEmB,IAAI,CAAC;QAC9C,IAAIC,QAAQ,KAAK,CAAC,CAAC,EAAE;UACnB,MAAM,IAAIE,KAAK,CAAC,2CAA2C,GAAGH,IAAI,CAAC;QACrE;QAEAF,cAAc,CAACE,IAAI,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGH,QAAQ;MAC1C,CAAC,MAAM,IAAID,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7CC,QAAQ,GAAGzC,EAAE,CAAC6C,kBAAkB,CAACxB,OAAO,EAAEmB,IAAI,CAAC;QAC/C,IAAIC,QAAQ,KAAK,IAAI,EAAE;UACrB,MAAM,IAAIE,KAAK,CAAC,yCAAyC,GAAGH,IAAI,CAAC;QACnE;QAEAF,cAAc,CAACE,IAAI,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGH,QAAQ;MAC1C,CAAC,MAAM;QACL,MAAM,IAAIE,KAAK,CAAC,uGAAuG,CAAC;MAC1H;IACF;IAEA,OAAOL,cAAc;EACvB;AACF;AAEA,SAASnC,aAAaA,CAAC2C,KAAK,EAAEC,EAAE,EAAEC,IAAI,EAAEC,aAAa,EAAE;EACrD,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,aAAa,EAAE,EAAEV,CAAC,EAAE;IACtCO,KAAK,CAACC,EAAE,GAAGR,CAAC,CAAC,GAAGO,KAAK,CAACE,IAAI,GAAGT,CAAC,CAAC;EACjC;AACF;AAEA,SAASnC,aAAaA,CAAC0C,KAAK,EAAEE,IAAI,EAAED,EAAE,EAAEE,aAAa,EAAE;EACrD,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,aAAa,EAAE,EAAEV,CAAC,EAAE;IACtC,IAAIW,GAAG,GAAGJ,KAAK,CAACE,IAAI,GAAGT,CAAC,CAAC;IACzBO,KAAK,CAACE,IAAI,GAAGT,CAAC,CAAC,GAAGO,KAAK,CAACC,EAAE,GAAGR,CAAC,CAAC;IAC/BO,KAAK,CAACC,EAAE,GAAGR,CAAC,CAAC,GAAGW,GAAG;EACrB;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}