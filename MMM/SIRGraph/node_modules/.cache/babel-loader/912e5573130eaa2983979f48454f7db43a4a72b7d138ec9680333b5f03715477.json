{"ast":null,"code":"/**\n * This is Barnes Hut simulation algorithm for 2d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n */\n\nmodule.exports = function (options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  // we require deterministic randomness here\n  var random = require('ngraph.random').random(1984),\n    Node = require('./node'),\n    InsertStack = require('./insertStack'),\n    isSamePosition = require('./isSamePosition');\n  var gravity = options.gravity,\n    updateQueue = [],\n    insertStack = new InsertStack(),\n    theta = options.theta,\n    nodesCache = [],\n    currentInCache = 0,\n    root = newNode();\n  return {\n    insertBodies: insertBodies,\n    /**\n     * Gets root node if its present\n     */\n    getRoot: function getRoot() {\n      return root;\n    },\n    updateBodyForce: update,\n    options: function options(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n        return this;\n      }\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n    if (node) {\n      node.quad0 = null;\n      node.quad1 = null;\n      node.quad2 = null;\n      node.quad3 = null;\n      node.body = null;\n      node.mass = node.massX = node.massY = 0;\n      node.left = node.right = node.top = node.bottom = 0;\n    } else {\n      node = new Node();\n      nodesCache[currentInCache] = node;\n    }\n    ++currentInCache;\n    return node;\n  }\n  function update(sourceBody) {\n    var queue = updateQueue,\n      v,\n      dx,\n      dy,\n      r,\n      fx = 0,\n      fy = 0,\n      queueLength = 1,\n      shiftIdx = 0,\n      pushIdx = 1;\n    queue[0] = root;\n    while (queueLength) {\n      var node = queue[shiftIdx],\n        body = node.body;\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = body !== sourceBody;\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        dx = body.pos.x - sourceBody.pos.x;\n        dy = body.pos.y - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // This is standard gravition force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        fx += v * dx;\n        fy += v * dy;\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        dx = node.massX / node.mass - sourceBody.pos.x;\n        dy = node.massY / node.mass - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n        if (r === 0) {\n          // Sorry about code duplucation. I don't want to create many functions\n          // right away. Just want to see performance first.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n        // If s / r < Î¸, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.right - node.left) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was squarified during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n          if (node.quad0) {\n            queue[pushIdx] = node.quad0;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad1) {\n            queue[pushIdx] = node.quad1;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad2) {\n            queue[pushIdx] = node.quad2;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad3) {\n            queue[pushIdx] = node.quad3;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n        }\n      }\n    }\n    sourceBody.force.x += fx;\n    sourceBody.force.y += fy;\n  }\n  function insertBodies(bodies) {\n    var x1 = Number.MAX_VALUE,\n      y1 = Number.MAX_VALUE,\n      x2 = Number.MIN_VALUE,\n      y2 = Number.MIN_VALUE,\n      i,\n      max = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    i = max;\n    while (i--) {\n      var x = bodies[i].pos.x;\n      var y = bodies[i].pos.y;\n      if (x < x1) {\n        x1 = x;\n      }\n      if (x > x2) {\n        x2 = x;\n      }\n      if (y < y1) {\n        y1 = y;\n      }\n      if (y > y2) {\n        y2 = y;\n      }\n    }\n\n    // Squarify the bounds.\n    var dx = x2 - x1,\n      dy = y2 - y1;\n    if (dx > dy) {\n      y2 = y1 + dx;\n    } else {\n      x2 = x1 + dy;\n    }\n    currentInCache = 0;\n    root = newNode();\n    root.left = x1;\n    root.right = x2;\n    root.top = y1;\n    root.bottom = y2;\n    i = max - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop(),\n        node = stackItem.node,\n        body = stackItem.body;\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        var x = body.pos.x;\n        var y = body.pos.y;\n        node.mass = node.mass + body.mass;\n        node.massX = node.massX + body.mass * x;\n        node.massY = node.massY + body.mass * y;\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx = 0,\n          // Assume we are in the 0's quad.\n          left = node.left,\n          right = (node.right + left) / 2,\n          top = node.top,\n          bottom = (node.bottom + top) / 2;\n        if (x > right) {\n          // somewhere in the eastern part.\n          quadIdx = quadIdx + 1;\n          left = right;\n          right = node.right;\n        }\n        if (y > bottom) {\n          // and in south.\n          quadIdx = quadIdx + 2;\n          top = bottom;\n          bottom = node.bottom;\n        }\n        var child = getChild(node, quadIdx);\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          child.left = left;\n          child.top = top;\n          child.right = right;\n          child.bottom = bottom;\n          child.body = body;\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n          do {\n            var offset = random.nextDouble();\n            var dx = (node.right - node.left) * offset;\n            var dy = (node.bottom - node.top) * offset;\n            oldBody.pos.x = node.left + dx;\n            oldBody.pos.y = node.top + dy;\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n};\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  return null;\n}\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;else if (idx === 1) node.quad1 = child;else if (idx === 2) node.quad2 = child;else if (idx === 3) node.quad3 = child;\n}","map":{"version":3,"names":["module","exports","options","gravity","theta","random","require","Node","InsertStack","isSamePosition","updateQueue","insertStack","nodesCache","currentInCache","root","newNode","insertBodies","getRoot","updateBodyForce","update","newOptions","node","quad0","quad1","quad2","quad3","body","mass","massX","massY","left","right","top","bottom","sourceBody","queue","v","dx","dy","r","fx","fy","queueLength","shiftIdx","pushIdx","differentBody","pos","x","y","Math","sqrt","nextDouble","force","bodies","x1","Number","MAX_VALUE","y1","x2","MIN_VALUE","y2","i","max","length","insert","newBody","reset","push","isEmpty","stackItem","pop","quadIdx","child","getChild","setChild","oldBody","retriesCount","offset","idx"],"sources":["/Users/zamanlh/github/MMM_Worksheets/networksir/node_modules/ngraph.quadtreebh/index.js"],"sourcesContent":["/**\n * This is Barnes Hut simulation algorithm for 2d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n */\n\nmodule.exports = function(options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  // we require deterministic randomness here\n  var random = require('ngraph.random').random(1984),\n    Node = require('./node'),\n    InsertStack = require('./insertStack'),\n    isSamePosition = require('./isSamePosition');\n\n  var gravity = options.gravity,\n    updateQueue = [],\n    insertStack = new InsertStack(),\n    theta = options.theta,\n\n    nodesCache = [],\n    currentInCache = 0,\n    root = newNode();\n\n  return {\n    insertBodies: insertBodies,\n    /**\n     * Gets root node if its present\n     */\n    getRoot: function() {\n      return root;\n    },\n    updateBodyForce: update,\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n    if (node) {\n      node.quad0 = null;\n      node.quad1 = null;\n      node.quad2 = null;\n      node.quad3 = null;\n      node.body = null;\n      node.mass = node.massX = node.massY = 0;\n      node.left = node.right = node.top = node.bottom = 0;\n    } else {\n      node = new Node();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue = updateQueue,\n      v,\n      dx,\n      dy,\n      r, fx = 0,\n      fy = 0,\n      queueLength = 1,\n      shiftIdx = 0,\n      pushIdx = 1;\n\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx],\n        body = node.body;\n\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = (body !== sourceBody);\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        dx = body.pos.x - sourceBody.pos.x;\n        dy = body.pos.y - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // This is standard gravition force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        fx += v * dx;\n        fy += v * dy;\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        dx = node.massX / node.mass - sourceBody.pos.x;\n        dy = node.massY / node.mass - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Sorry about code duplucation. I don't want to create many functions\n          // right away. Just want to see performance first.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n        // If s / r < Î¸, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.right - node.left) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was squarified during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n          if (node.quad0) {\n            queue[pushIdx] = node.quad0;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad1) {\n            queue[pushIdx] = node.quad1;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad2) {\n            queue[pushIdx] = node.quad2;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad3) {\n            queue[pushIdx] = node.quad3;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n        }\n      }\n    }\n\n    sourceBody.force.x += fx;\n    sourceBody.force.y += fy;\n  }\n\n  function insertBodies(bodies) {\n    var x1 = Number.MAX_VALUE,\n      y1 = Number.MAX_VALUE,\n      x2 = Number.MIN_VALUE,\n      y2 = Number.MIN_VALUE,\n      i,\n      max = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    i = max;\n    while (i--) {\n      var x = bodies[i].pos.x;\n      var y = bodies[i].pos.y;\n      if (x < x1) {\n        x1 = x;\n      }\n      if (x > x2) {\n        x2 = x;\n      }\n      if (y < y1) {\n        y1 = y;\n      }\n      if (y > y2) {\n        y2 = y;\n      }\n    }\n\n    // Squarify the bounds.\n    var dx = x2 - x1,\n      dy = y2 - y1;\n    if (dx > dy) {\n      y2 = y1 + dx;\n    } else {\n      x2 = x1 + dy;\n    }\n\n    currentInCache = 0;\n    root = newNode();\n    root.left = x1;\n    root.right = x2;\n    root.top = y1;\n    root.bottom = y2;\n\n    i = max - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop(),\n        node = stackItem.node,\n        body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        var x = body.pos.x;\n        var y = body.pos.y;\n        node.mass = node.mass + body.mass;\n        node.massX = node.massX + body.mass * x;\n        node.massY = node.massY + body.mass * y;\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx = 0, // Assume we are in the 0's quad.\n          left = node.left,\n          right = (node.right + left) / 2,\n          top = node.top,\n          bottom = (node.bottom + top) / 2;\n\n        if (x > right) { // somewhere in the eastern part.\n          quadIdx = quadIdx + 1;\n          left = right;\n          right = node.right;\n        }\n        if (y > bottom) { // and in south.\n          quadIdx = quadIdx + 2;\n          top = bottom;\n          bottom = node.bottom;\n        }\n\n        var child = getChild(node, quadIdx);\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          child.left = left;\n          child.top = top;\n          child.right = right;\n          child.bottom = bottom;\n          child.body = body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n          do {\n            var offset = random.nextDouble();\n            var dx = (node.right - node.left) * offset;\n            var dy = (node.bottom - node.top) * offset;\n\n            oldBody.pos.x = node.left + dx;\n            oldBody.pos.y = node.top + dy;\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;\n  else if (idx === 1) node.quad1 = child;\n  else if (idx === 2) node.quad2 = child;\n  else if (idx === 3) node.quad3 = child;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}